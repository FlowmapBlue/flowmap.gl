{"version":3,"file":"static/js/735.df780a5a.chunk.js","mappings":"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","sources":["../../../packages/data/src/cluster/cluster.ts","../../../packages/data/src/types.ts","../../../packages/data/src/colors.ts","../../../packages/data/src/FlowmapAggregateAccessors.ts","../../../packages/data/src/time.ts","../../../packages/data/src/FlowmapSelectors.ts","../../../packages/data/src/cluster/ClusterIndex.ts","../../../packages/data/src/getViewStateForLocations.ts","../../../packages/data/src/provider/LocalFlowmapDataProvider.ts","../../../packages/data/src/provider/WorkerFlowmapDataProvider.ts","../../../packages/data/src/provider/WorkerFlowmapDataProviderWorker.ts","../webpack/bootstrap","../webpack/runtime/amd define","../webpack/runtime/amd options","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["/*\n * Copyright 2022 FlowmapBlue\n * Copyright 2018-2020 Teralytics, modified by FlowmapBlue\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * The code in this file is a based on https://github.com/mapbox/supercluster\n */\n\n// ISC License\n//\n// Copyright (c) 2016, Mapbox\n//\n// Permission to use, copy, modify, and/or distribute this software for any purpose\n// with or without fee is hereby granted, provided that the above copyright notice\n// and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n// THIS SOFTWARE.\n\nimport {rollup} from 'd3-array';\nimport KDBush from 'kdbush';\nimport {LocationWeightGetter} from './ClusterIndex';\nimport {Cluster, ClusterLevel, ClusterNode, LocationAccessors} from '../types';\n\nexport interface Options {\n  minZoom: number; // min zoom to generate clusters on\n  maxZoom: number; // max zoom level to cluster the points on\n  radius: number; // cluster radius in pixels\n  extent: number; // tile extent (radius is calculated relative to it)\n  nodeSize: number; // size of the KD-tree leaf node, affects performance\n  makeClusterName: (id: number, numPoints: number) => string | undefined;\n  makeClusterId: (id: number) => string;\n}\n\nconst defaultOptions: Options = {\n  minZoom: 0,\n  maxZoom: 16,\n  radius: 40,\n  extent: 512,\n  nodeSize: 64,\n  makeClusterName: (id: number, numPoints: number) => undefined,\n  makeClusterId: (id: number) => `{[${id}]}`,\n};\n\ninterface BasePoint {\n  x: number; // projected point coordinates\n  y: number;\n  weight: number;\n  zoom: number; // the last zoom the point was processed at\n  parentId: number; // parent cluster id\n}\n\ninterface LeafPoint extends BasePoint {\n  index: number; // index of the source feature in the original input array,\n}\n\ninterface ClusterPoint extends BasePoint {\n  id: number;\n  numPoints: number;\n}\n\ntype Point = LeafPoint | ClusterPoint;\n\nexport function isLeafPoint(p: Point): p is LeafPoint {\n  const {index} = p as LeafPoint;\n  return index != null;\n}\n\nexport function isClusterPoint(p: Point): p is ClusterPoint {\n  const {id} = p as ClusterPoint;\n  return id != null;\n}\n\ntype ZoomLevelKDBush = any;\n\nexport function clusterLocations<L>(\n  locations: L[],\n  locationAccessors: LocationAccessors<L>,\n  getLocationWeight: LocationWeightGetter,\n  options?: Partial<Options>,\n): ClusterLevel[] {\n  const {getLocationCentroid, getLocationId} = locationAccessors;\n  const opts = {\n    ...defaultOptions,\n    ...options,\n  };\n  const {minZoom, maxZoom, nodeSize, makeClusterName, makeClusterId} = opts;\n\n  const trees = new Array<ZoomLevelKDBush>(maxZoom + 1);\n\n  // generate a cluster object for each point and index input points into a KD-tree\n  let clusters = new Array<Point>();\n  for (let i = 0; i < locations.length; i++) {\n    const [x, y] = getLocationCentroid(locations[i]);\n    clusters.push({\n      x: lngX(x), // projected point coordinates\n      y: latY(y),\n      weight: getLocationWeight(getLocationId(locations[i])),\n      zoom: Infinity, // the last zoom the point was processed at\n      index: i, // index of the source feature in the original input array,\n      parentId: -1, // parent cluster id\n    });\n  }\n  trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n  // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n  // results in a cluster hierarchy across zoom levels\n  for (let z = maxZoom; z >= minZoom; z--) {\n    // create a new set of clusters for the zoom and index them with a KD-tree\n    clusters = cluster(clusters, z, trees[z + 1], opts);\n    trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n  }\n\n  if (trees.length === 0) {\n    return [];\n  }\n  const numbersOfClusters = trees.map((d) => d.points.length);\n  const maxAvailZoom = numbersOfClusters.indexOf(\n    numbersOfClusters[numbersOfClusters.length - 1],\n  );\n  const minAvailZoom = Math.min(\n    maxAvailZoom,\n    numbersOfClusters.lastIndexOf(numbersOfClusters[0]),\n  );\n\n  const clusterLevels = new Array<ClusterLevel>();\n  for (let zoom = minAvailZoom; zoom <= maxAvailZoom; zoom++) {\n    let childrenByParent: Map<number, string[]> | undefined;\n    const tree = trees[zoom];\n    if (zoom < maxAvailZoom) {\n      childrenByParent = rollup<Point, string[], number>(\n        trees[zoom + 1].points,\n        (points: any[]) =>\n          points.map((p: any) =>\n            p.id ? makeClusterId(p.id) : getLocationId(locations[p.index]),\n          ),\n        (point: any) => point.parentId,\n      );\n    }\n\n    const nodes: ClusterNode[] = [];\n    for (const point of tree.points) {\n      const {x, y, numPoints} = point;\n      if (isLeafPoint(point)) {\n        const location = locations[point.index];\n        nodes.push({\n          id: getLocationId(location),\n          zoom,\n          centroid: getLocationCentroid(location),\n        });\n      } else if (isClusterPoint(point)) {\n        const {id} = point;\n        const children = childrenByParent && childrenByParent.get(id);\n        if (!children) {\n          throw new Error(`Cluster ${id} doesn't have children`);\n        }\n        nodes.push({\n          id: makeClusterId(id),\n          name: makeClusterName(id, numPoints),\n          zoom,\n          centroid: [xLng(x), yLat(y)] as [number, number],\n          children,\n        } as Cluster);\n      }\n    }\n    clusterLevels.push({\n      zoom,\n      nodes,\n    });\n  }\n  return clusterLevels;\n}\n\nfunction createCluster(\n  x: number,\n  y: number,\n  id: number,\n  numPoints: number,\n  weight: number,\n): ClusterPoint {\n  return {\n    x, // weighted cluster center\n    y,\n    zoom: Infinity, // the last zoom the cluster was processed at\n    id, // encodes index of the first child of the cluster and its zoom level\n    parentId: -1, // parent cluster id\n    numPoints,\n    weight,\n  };\n}\n\nfunction cluster(\n  points: Point[],\n  zoom: number,\n  tree: ZoomLevelKDBush,\n  options: Options,\n) {\n  const clusters: Point[] = [];\n  const {radius, extent} = options;\n  const r = radius / (extent * Math.pow(2, zoom));\n\n  // loop through each point\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    // if we've already visited the point at this zoom level, skip it\n    if (p.zoom <= zoom) {\n      continue;\n    }\n    p.zoom = zoom;\n\n    // find all nearby points\n    const neighborIds = tree.within(p.x, p.y, r);\n\n    let weight = p.weight || 1;\n    let numPoints = isClusterPoint(p) ? p.numPoints : 1;\n    let wx = p.x * weight;\n    let wy = p.y * weight;\n\n    // encode both zoom and point index on which the cluster originated\n    const id = (i << 5) + (zoom + 1);\n\n    for (const neighborId of neighborIds) {\n      const b = tree.points[neighborId];\n      // filter out neighbors that are already processed\n      if (b.zoom <= zoom) {\n        continue;\n      }\n      b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n      const weight2 = b.weight || 1;\n      const numPoints2 = b.numPoints || 1;\n      wx += b.x * weight2; // accumulate coordinates for calculating weighted center\n      wy += b.y * weight2;\n\n      weight += weight2;\n      numPoints += numPoints2;\n      b.parentId = id;\n    }\n\n    if (numPoints === 1) {\n      clusters.push(p);\n    } else {\n      p.parentId = id;\n      clusters.push(\n        createCluster(wx / weight, wy / weight, id, numPoints, weight),\n      );\n    }\n  }\n\n  return clusters;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x: number) {\n  return (x - 0.5) * 360;\n}\n\nfunction yLat(y: number) {\n  const y2 = ((180 - y * 360) * Math.PI) / 180;\n  return (360 * Math.atan(Math.exp(y2))) / Math.PI - 90;\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng: number) {\n  return lng / 360 + 0.5;\n}\n\nfunction latY(lat: number) {\n  const sin = Math.sin((lat * Math.PI) / 180);\n  const y = 0.5 - (0.25 * Math.log((1 + sin) / (1 - sin))) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\nfunction getX(p: Point) {\n  return p.x;\n}\n\nfunction getY(p: Point) {\n  return p.y;\n}\n","export type FlowmapData<L, F> = {\n  locations: L[] | undefined;\n  flows: F[] | undefined;\n};\n\nexport interface ViewState {\n  latitude: number;\n  longitude: number;\n  zoom: number;\n  bearing?: number;\n  pitch?: number;\n  altitude?: number;\n}\n\nexport type FlowAccessor<F, T> = (flow: F) => T; // objectInfo?: AccessorObjectInfo,\nexport type LocationAccessor<L, T> = (location: L) => T;\n\nexport interface FlowAccessors<F> {\n  getFlowOriginId: FlowAccessor<F, string>;\n  getFlowDestId: FlowAccessor<F, string>;\n  getFlowMagnitude: FlowAccessor<F, number>;\n  getFlowTime?: FlowAccessor<F, Date>; // TODO: use number instead of Date\n  // getFlowColor?: FlowAccessor<string | undefined>;\n}\n\nexport interface LocationAccessors<L> {\n  getLocationId: LocationAccessor<L, string>;\n  getLocationName?: LocationAccessor<L, string>;\n  getLocationCentroid: LocationAccessor<L, [number, number]>;\n  getLocationClusterName?: (locationIds: string[]) => string;\n  // getLocationTotalIn?: LocationAccessor<number>;\n  // getLocationTotalOut?: LocationAccessor<number>;\n  // getLocationTotalInternal?: LocationAccessor<number>;\n}\n\nexport type FlowmapDataAccessors<L, F> = LocationAccessors<L> &\n  FlowAccessors<F>;\n\nexport interface LocationTotals {\n  incomingCount: number;\n  outgoingCount: number;\n  internalCount: number;\n}\n\n// export interface LocationsTotals {\n//   incoming: {[id: string]: number};\n//   outgoing: {[id: string]: number};\n//   internal: {[id: string]: number};\n// }\n\nexport interface CountByTime {\n  time: Date;\n  count: number;\n}\n\nexport interface ViewportProps {\n  width: number;\n  height: number;\n  latitude: number;\n  longitude: number;\n  zoom: number;\n  bearing: number;\n  pitch: number;\n  altitude?: number;\n  maxZoom?: number;\n  minZoom?: number;\n  maxPitch?: number;\n  minPitch?: number;\n  transitionDuration?: number | 'auto';\n  transitionInterpolator?: any;\n  transitionInterruption?: any;\n  transitionEasing?: any;\n}\n\nexport interface ClusterNode {\n  id: string;\n  zoom: number;\n  centroid: [number, number];\n}\n\nexport interface ClusterLevel {\n  zoom: number;\n  nodes: ClusterNode[];\n}\n\nexport type ClusterLevels = ClusterLevel[];\n\n// non-leaf cluster node\nexport interface Cluster extends ClusterNode {\n  name?: string;\n  children: string[];\n}\n\nexport function isCluster(c: ClusterNode): c is Cluster {\n  const {children} = c as Cluster;\n  return children && children.length > 0;\n}\n\nexport function isLocationClusterNode<L>(l: L | ClusterNode): l is ClusterNode {\n  const {zoom} = l as ClusterNode;\n  return zoom !== undefined;\n}\n\nexport interface AggregateFlow {\n  origin: string;\n  dest: string;\n  count: number;\n  aggregate: true;\n}\n\nexport function isAggregateFlow(\n  flow: Record<string, any>,\n): flow is AggregateFlow {\n  return (\n    flow &&\n    flow.origin !== undefined &&\n    flow.dest !== undefined &&\n    flow.count !== undefined &&\n    (flow.aggregate ? true : false)\n  );\n}\n\nexport interface FlowCountsMapReduce<F, T = any> {\n  map: (flow: F) => T;\n  reduce: (accumulated: T, val: T) => T;\n}\n\nexport enum LocationFilterMode {\n  ALL = 'ALL',\n  INCOMING = 'INCOMING',\n  OUTGOING = 'OUTGOING',\n  BETWEEN = 'BETWEEN',\n}\n\nexport interface FlowCirclesLayerAttributes {\n  length: number;\n  attributes: {\n    getPosition: LayersDataAttrValues<Float32Array>;\n    getColor: LayersDataAttrValues<Uint8Array>;\n    getInRadius: LayersDataAttrValues<Float32Array>;\n    getOutRadius: LayersDataAttrValues<Float32Array>;\n  };\n}\n\nexport interface FlowLinesLayerAttributes {\n  length: number;\n  attributes: {\n    getSourcePosition: LayersDataAttrValues<Float32Array>;\n    getTargetPosition: LayersDataAttrValues<Float32Array>;\n    getThickness: LayersDataAttrValues<Float32Array>;\n    getColor: LayersDataAttrValues<Uint8Array>;\n    getEndpointOffsets: LayersDataAttrValues<Float32Array>;\n    getStaggering?: LayersDataAttrValues<Float32Array>;\n  };\n}\n\nexport interface LayersData {\n  circleAttributes: FlowCirclesLayerAttributes;\n  lineAttributes: FlowLinesLayerAttributes;\n}\n\nexport type LayersDataAttrValues<T> = {value: T; size: number};\n","import {\n  interpolateCool,\n  interpolateInferno,\n  interpolateMagma,\n  interpolatePlasma,\n  interpolateViridis,\n  interpolateWarm,\n  schemeBlues,\n  schemeBuGn,\n  schemeBuPu,\n  schemeGnBu,\n  schemeGreens,\n  schemeGreys,\n  schemeOranges,\n  schemeOrRd,\n  schemePuBu,\n  schemePuBuGn,\n  schemePuRd,\n  schemePurples,\n  schemeRdPu,\n  schemeReds,\n  schemeYlGn,\n  schemeYlGnBu,\n  schemeYlOrBr,\n  schemeYlOrRd,\n} from 'd3-scale-chromatic';\nimport {range} from 'd3-array';\nimport {scalePow, scaleSequential, scaleSequentialPow} from 'd3-scale';\nimport {interpolateBasis, interpolateRgbBasis} from 'd3-interpolate';\nimport {color as d3color, hcl, rgb as colorRgb} from 'd3-color';\nimport {SettingsState} from './FlowmapState';\n\nconst DEFAULT_OUTLINE_COLOR = '#fff';\nconst DEFAULT_DIMMED_OPACITY = 0.4;\nconst DEFAULT_FLOW_MIN_COLOR = 'rgba(240,240,240,0.5)';\nconst DEFAULT_FLOW_COLOR_SCHEME = [DEFAULT_FLOW_MIN_COLOR, '#137CBD'];\nconst DEFAULT_LOCATION_AREA_COLOR = 'rgba(220,220,220,0.5)';\n\nconst DEFAULT_FLOW_COLOR_SCHEME_POSITIVE = [DEFAULT_FLOW_MIN_COLOR, '#f6654e'];\nconst DEFAULT_FLOW_COLOR_SCHEME_NEGATIVE = [DEFAULT_FLOW_MIN_COLOR, '#00a9cc'];\n\nexport type ColorScale = (value: number) => RGBA;\nexport type RGBA = [number, number, number, number];\n\nconst FALLBACK_COLOR_RGBA: RGBA = [255, 255, 255, 255];\n\nexport function opacityFloatToInteger(opacity: number): number {\n  return Math.round(opacity * 255);\n}\n\nexport function opacifyHex(hexCode: string, opacity: number): string {\n  const c = d3color(hexCode);\n  if (!c) {\n    console.warn('Invalid color: ', hexCode);\n    return `rgba(255, 255, 255, ${opacity})`;\n  }\n  const col = c.rgb();\n  return `rgba(${col.r}, ${col.g}, ${col.b}, ${opacity})`;\n}\n\nexport function colorAsRgba(color: string): RGBA {\n  const col = d3color(color);\n  if (!col) {\n    console.warn('Invalid color: ', color);\n    return FALLBACK_COLOR_RGBA;\n  }\n  const rgbColor = col.rgb();\n  return [\n    Math.floor(rgbColor.r),\n    Math.floor(rgbColor.g),\n    Math.floor(rgbColor.b),\n    opacityFloatToInteger(col.opacity),\n  ];\n}\n\nfunction colorAsRgbaOr(\n  color: string | undefined,\n  defaultColor: RGBA | string,\n): RGBA {\n  if (color) {\n    return colorAsRgba(color);\n  }\n  if (typeof defaultColor === 'string') {\n    return colorAsRgba(defaultColor);\n  }\n  return defaultColor;\n}\n\nconst asScheme = (scheme: ReadonlyArray<ReadonlyArray<string>>) =>\n  scheme[scheme.length - 1] as string[];\n\nexport enum ColorScheme {\n  primary = '#162d3c',\n}\n\nconst SCALE_NUM_STEPS = 20;\nconst getColorSteps = (interpolate: (x: number) => string) =>\n  range(0, SCALE_NUM_STEPS + 1)\n    .map((i) => interpolate(i / SCALE_NUM_STEPS))\n    .reverse();\n\nconst FLOW_MIN_COLOR = 'rgba(240,240,240,0.5)';\nexport const GRAYISH = [FLOW_MIN_COLOR, ColorScheme.primary];\nconst schemeBluYl = [\n  '#f7feae',\n  '#b7e6a5',\n  '#7ccba2',\n  '#46aea0',\n  '#089099',\n  '#00718b',\n  '#045275',\n];\n\nconst schemeEmrld = [\n  '#d3f2a3',\n  '#97e196',\n  '#6cc08b',\n  '#4c9b82',\n  '#217a79',\n  '#105965',\n  '#074050',\n];\n\nexport const schemeTeal = [\n  '#d1eeea',\n  '#a8dbd9',\n  '#85c4c9',\n  '#68abb8',\n  '#4f90a6',\n  '#3b738f',\n  '#2a5674',\n];\n\nexport const DEFAULT_COLOR_SCHEME = schemeTeal;\nexport const COLOR_SCHEMES: {[key: string]: string[]} = {\n  Blues: asScheme(schemeBlues),\n  BluGrn: [\n    '#c4e6c3',\n    '#96d2a4',\n    '#6dbc90',\n    '#4da284',\n    '#36877a',\n    '#266b6e',\n    '#1d4f60',\n  ],\n  BluYl: schemeBluYl,\n  BrwnYl: [\n    '#ede5cf',\n    '#e0c2a2',\n    '#d39c83',\n    '#c1766f',\n    '#a65461',\n    '#813753',\n    '#541f3f',\n  ],\n  BuGn: asScheme(schemeBuGn),\n  BuPu: asScheme(schemeBuPu),\n  Burg: [\n    '#ffc6c4',\n    '#f4a3a8',\n    '#e38191',\n    '#cc607d',\n    '#ad466c',\n    '#8b3058',\n    '#672044',\n  ],\n  BurgYl: [\n    '#fbe6c5',\n    '#f5ba98',\n    '#ee8a82',\n    '#dc7176',\n    '#c8586c',\n    '#9c3f5d',\n    '#70284a',\n  ],\n  Cool: getColorSteps(interpolateCool),\n  DarkMint: [\n    '#d2fbd4',\n    '#a5dbc2',\n    '#7bbcb0',\n    '#559c9e',\n    '#3a7c89',\n    '#235d72',\n    '#123f5a',\n  ],\n  Emrld: schemeEmrld,\n  GnBu: asScheme(schemeGnBu),\n  Grayish: GRAYISH,\n  Greens: asScheme(schemeGreens),\n  Greys: asScheme(schemeGreys),\n  Inferno: getColorSteps(interpolateInferno),\n  Magenta: [\n    '#f3cbd3',\n    '#eaa9bd',\n    '#dd88ac',\n    '#ca699d',\n    '#b14d8e',\n    '#91357d',\n    '#6c2167',\n  ],\n  Magma: getColorSteps(interpolateMagma),\n  Mint: [\n    '#e4f1e1',\n    '#b4d9cc',\n    '#89c0b6',\n    '#63a6a0',\n    '#448c8a',\n    '#287274',\n    '#0d585f',\n  ],\n  Oranges: asScheme(schemeOranges),\n  OrRd: asScheme(schemeOrRd),\n  OrYel: [\n    '#ecda9a',\n    '#efc47e',\n    '#f3ad6a',\n    '#f7945d',\n    '#f97b57',\n    '#f66356',\n    '#ee4d5a',\n  ],\n  Peach: [\n    '#fde0c5',\n    '#facba6',\n    '#f8b58b',\n    '#f59e72',\n    '#f2855d',\n    '#ef6a4c',\n    '#eb4a40',\n  ],\n  Plasma: getColorSteps(interpolatePlasma),\n  PinkYl: [\n    '#fef6b5',\n    '#ffdd9a',\n    '#ffc285',\n    '#ffa679',\n    '#fa8a76',\n    '#f16d7a',\n    '#e15383',\n  ],\n  PuBu: asScheme(schemePuBu),\n  PuBuGn: asScheme(schemePuBuGn),\n  PuRd: asScheme(schemePuRd),\n  Purp: [\n    '#f3e0f7',\n    '#e4c7f1',\n    '#d1afe8',\n    '#b998dd',\n    '#9f82ce',\n    '#826dba',\n    '#63589f',\n  ],\n  Purples: asScheme(schemePurples),\n  PurpOr: [\n    '#f9ddda',\n    '#f2b9c4',\n    '#e597b9',\n    '#ce78b3',\n    '#ad5fad',\n    '#834ba0',\n    '#573b88',\n  ],\n  RdPu: asScheme(schemeRdPu),\n  RedOr: [\n    '#f6d2a9',\n    '#f5b78e',\n    '#f19c7c',\n    '#ea8171',\n    '#dd686c',\n    '#ca5268',\n    '#b13f64',\n  ],\n  Reds: asScheme(schemeReds),\n  Sunset: [\n    '#f3e79b',\n    '#fac484',\n    '#f8a07e',\n    '#eb7f86',\n    '#ce6693',\n    '#a059a0',\n    '#5c53a5',\n  ],\n  SunsetDark: [\n    '#fcde9c',\n    '#faa476',\n    '#f0746e',\n    '#e34f6f',\n    '#dc3977',\n    '#b9257a',\n    '#7c1d6f',\n  ],\n  Teal: schemeTeal,\n  TealGrn: [\n    '#b0f2bc',\n    '#89e8ac',\n    '#67dba5',\n    '#4cc8a3',\n    '#38b2a3',\n    '#2c98a0',\n    '#257d98',\n  ],\n  Viridis: getColorSteps(interpolateViridis),\n  Warm: getColorSteps(interpolateWarm),\n  YlGn: asScheme(schemeYlGn),\n  YlGnBu: asScheme(schemeYlGnBu),\n  YlOrBr: asScheme(schemeYlOrBr),\n  YlOrRd: asScheme(schemeYlOrRd),\n};\n\nexport const COLOR_SCHEME_KEYS = Object.keys(COLOR_SCHEMES);\n\nconst complementary = '#f52020';\nconst baseDiffColor = '#17a5be';\n\nconst diffColors: DiffColors = {\n  negative: {\n    flows: {\n      scheme: [FLOW_MIN_COLOR, baseDiffColor],\n    },\n  },\n  positive: {\n    flows: {\n      scheme: [FLOW_MIN_COLOR, complementary],\n    },\n  },\n  locationAreas: {\n    outline: 'rgba(92,112,128,0.5)',\n    normal: 'rgba(220,220,220,0.5)',\n  },\n  outlineColor: 'rgb(230,233,237)',\n};\n\nexport function getFlowmapColors(\n  settingsState: SettingsState,\n): Colors | DiffColors {\n  return getColors(\n    false, // TODO: diffMode\n    settingsState.colorScheme,\n    settingsState.darkMode,\n    settingsState.fadeEnabled,\n    settingsState.fadeOpacityEnabled,\n    settingsState.fadeAmount,\n    settingsState.animationEnabled,\n  );\n}\n\nexport function getColors(\n  diffMode: boolean,\n  schemeKey: string | undefined,\n  darkMode: boolean,\n  fadeEnabled: boolean,\n  fadeOpacityEnabled: boolean,\n  fadeAmount: number,\n  animate: boolean,\n): Colors | DiffColors {\n  if (diffMode) {\n    return diffColors;\n  }\n\n  let scheme = (schemeKey && COLOR_SCHEMES[schemeKey]) || DEFAULT_COLOR_SCHEME;\n\n  if (darkMode) {\n    scheme = scheme.slice().reverse();\n  }\n  // if (animate)\n  // if (fadeAmount > 0)\n  {\n    const indices = range(0, Math.max(10, scheme.length));\n    const N = indices.length - 1;\n    const colorScale = scaleSequential(interpolateRgbBasis(scheme)).domain([\n      0,\n      N,\n    ]);\n\n    if (!fadeEnabled || fadeAmount === 0) {\n      scheme = indices.map((c, i) => colorScale(i));\n    } else {\n      const amount = scalePow()\n        // .exponent(animate ? 1 : 1/2.5)\n        // .exponent(animate ? 100 : 50)\n        // .exponent(animate ? 20 : 5)\n        // .exponent(1/2.5)\n        .exponent(1.5)\n        .domain([N, 0])\n        // .range([fadeAmount/100*(animate?2:1), 0])\n        // .range([0, fadeAmount/100*(animate?2:1)])\n        // .range(darkMode ? [1-fadeAmount/100, 1] : [1, 1 - fadeAmount/100])\n        // .range(darkMode ? [1 - fadeAmount/100, 1] : [fadeAmount/100, 0])\n        // .range([1 - fadeAmount/100, 1])\n        .range([0, (2 * fadeAmount) / 100]);\n\n      scheme = indices.map(\n        (c, i) => {\n          const color = colorScale(i);\n          const a = amount(i);\n          if (color == null || a == null) return '#000';\n          const col = hcl(color);\n          col.l = darkMode ? col.l - col.l * a : col.l + (100 - col.l) * a;\n          col.c = col.c - col.c * (a / 4);\n          if (fadeOpacityEnabled) {\n            col.opacity = col.opacity * (1.0 - a);\n          }\n          return col.toString();\n        },\n        // interpolateRgbBasis([colorScale(i), darkMode ? '#000' : '#fff'])(amount(i))\n        // interpolateHsl(colorScale(i), darkMode ? '#000' : '#fff')(amount(i)).toString()\n      );\n    }\n  }\n\n  return {\n    darkMode,\n    flows: {\n      scheme,\n    },\n    locationCircles: {\n      outgoing: darkMode ? '#000' : '#fff',\n    },\n    outlineColor: darkMode ? '#000' : 'rgba(255, 255, 255, 0.5)',\n  };\n}\n\nfunction interpolateRgbaBasis(colors: string[]) {\n  const spline = interpolateBasis;\n  const n = colors.length;\n  let r: any = new Array(n),\n    g: any = new Array(n),\n    b: any = new Array(n),\n    opacity: any = new Array(n),\n    i,\n    color: any;\n  for (i = 0; i < n; ++i) {\n    color = colorRgb(colors[i]);\n    r[i] = color.r || 0;\n    g[i] = color.g || 0;\n    b[i] = color.b || 0;\n    opacity[i] = color.opacity || 0;\n  }\n  r = spline(r);\n  g = spline(g);\n  b = spline(b);\n  opacity = spline(opacity);\n  // color.opacity = 1;\n  return function (t: number) {\n    color.r = r(t);\n    color.g = g(t);\n    color.b = b(t);\n    color.opacity = opacity(t);\n    return color + '';\n  };\n}\n\nexport function createFlowColorScale(\n  domain: [number, number],\n  scheme: string[],\n  animate: boolean | undefined,\n): ColorScale {\n  const scale = scaleSequentialPow(interpolateRgbaBasis(scheme))\n    // @ts-ignore\n    .exponent(animate ? 1 / 2 : 1 / 3)\n    .domain(domain);\n\n  return (value: number) => colorAsRgba(scale(value));\n}\n\nexport function getFlowColorScale(\n  colors: ColorsRGBA | DiffColorsRGBA,\n  magnitudeExtent: [number, number] | undefined,\n  animate: boolean | undefined,\n): (magnitude: number) => [number, number, number, number] {\n  const minMagnitude = magnitudeExtent ? magnitudeExtent[0] : 0;\n  const maxMagnitude = magnitudeExtent ? magnitudeExtent[1] : 0;\n  if (isDiffColorsRGBA(colors)) {\n    const posScale = createFlowColorScale(\n      [0, maxMagnitude],\n      colors.positive.flows.scheme,\n      animate,\n    );\n    const negScale = createFlowColorScale(\n      [0, minMagnitude],\n      colors.negative.flows.scheme,\n      animate,\n    );\n\n    return (magnitude: number) =>\n      magnitude >= 0 ? posScale(magnitude) : negScale(magnitude);\n  }\n\n  const scale = createFlowColorScale(\n    [0, maxMagnitude || 0],\n    colors.flows.scheme,\n    animate,\n  );\n  return (magnitude: number) => scale(magnitude);\n}\n\nexport function isDiffColors(\n  colors: DiffColors | Colors,\n): colors is DiffColors {\n  return (colors as DiffColors).positive !== undefined;\n}\n\nexport function isDiffColorsRGBA(\n  colors: DiffColorsRGBA | ColorsRGBA,\n): colors is DiffColorsRGBA {\n  return (colors as DiffColorsRGBA).positive !== undefined;\n}\n\nfunction getLocationAreaColorsRGBA(\n  colors: LocationAreaColors | undefined,\n  darkMode: boolean,\n): LocationAreaColorsRGBA {\n  const normalColor = (colors && colors.normal) || DEFAULT_LOCATION_AREA_COLOR;\n  const normalColorHcl = hcl(normalColor);\n  const locationAreasNormal = colorAsRgba(normalColor);\n  return {\n    normal: locationAreasNormal,\n    connected: colorAsRgbaOr(colors && colors.connected, locationAreasNormal),\n    highlighted: colorAsRgbaOr(\n      colors && colors.highlighted,\n      opacifyHex(\n        normalColorHcl[darkMode ? 'brighter' : 'darker'](1).toString(),\n        0.5,\n      ),\n    ),\n    selected: colorAsRgbaOr(\n      colors && colors.selected,\n      opacifyHex(\n        normalColorHcl[darkMode ? 'brighter' : 'darker'](2).toString(),\n        0.8,\n      ),\n    ),\n    outline: colorAsRgbaOr(\n      colors && colors.outline,\n      colorAsRgba(\n        normalColorHcl[darkMode ? 'brighter' : 'darker'](4).toString(),\n      ),\n    ),\n  };\n}\n\nexport interface FlowColors {\n  scheme?: string[];\n  highlighted?: string;\n}\n\nexport interface LocationCircleColors {\n  inner?: string;\n  outgoing?: string;\n  incoming?: string;\n  highlighted?: string;\n  empty?: string;\n  outlineEmptyMix?: number;\n}\n\nexport interface LocationAreaColors {\n  outline?: string;\n  normal?: string;\n  selected?: string;\n  highlighted?: string;\n  connected?: string;\n}\n\nexport interface BaseColors {\n  darkMode?: boolean;\n  locationAreas?: LocationAreaColors;\n  dimmedOpacity?: number;\n  outlineColor?: string;\n}\n\nexport interface Colors extends BaseColors {\n  flows?: FlowColors;\n  locationCircles?: LocationCircleColors;\n}\n\nexport interface FlowAndCircleColors {\n  flows?: FlowColors;\n  locationCircles?: LocationCircleColors;\n}\n\nexport interface DiffColors extends BaseColors {\n  positive?: FlowAndCircleColors;\n  negative?: FlowAndCircleColors;\n}\n\n// The xxxColorsRGBA objects are mirroring the input colors' objects,\n// but converted to RGBA and with all the omitted ones set to defaults\n// or derived.\nexport interface FlowColorsRGBA {\n  scheme: string[];\n  highlighted: RGBA;\n}\n\nexport interface LocationCircleColorsRGBA {\n  inner: RGBA;\n  outgoing: RGBA;\n  incoming: RGBA;\n  highlighted: RGBA;\n  empty: RGBA;\n  outlineEmptyMix: number;\n}\n\nexport interface LocationAreaColorsRGBA {\n  outline: RGBA;\n  normal: RGBA;\n  selected: RGBA;\n  highlighted: RGBA;\n  connected: RGBA;\n}\n\nexport interface BaseColorsRGBA {\n  darkMode: boolean;\n  locationAreas: LocationAreaColorsRGBA;\n  dimmedOpacity: number;\n  outlineColor: RGBA;\n}\n\nexport interface ColorsRGBA extends BaseColorsRGBA {\n  flows: FlowColorsRGBA;\n  locationCircles: LocationCircleColorsRGBA;\n}\n\nexport interface FlowAndCircleColorsRGBA {\n  flows: FlowColorsRGBA;\n  locationCircles: LocationCircleColorsRGBA;\n}\n\nexport interface DiffColorsRGBA extends BaseColorsRGBA {\n  positive: FlowAndCircleColorsRGBA;\n  negative: FlowAndCircleColorsRGBA;\n}\n\nfunction getFlowAndCircleColors(\n  inputColors: FlowAndCircleColors | undefined,\n  defaultFlowColorScheme: string[],\n  darkMode: boolean,\n): FlowAndCircleColorsRGBA {\n  const flowColorScheme =\n    (inputColors && inputColors.flows && inputColors.flows.scheme) ||\n    defaultFlowColorScheme;\n  const maxFlowColorHcl = hcl(flowColorScheme[flowColorScheme.length - 1]);\n  const flowColorHighlighted = colorAsRgbaOr(\n    inputColors && inputColors.flows && inputColors.flows.highlighted,\n    colorAsRgba(\n      maxFlowColorHcl[darkMode ? 'brighter' : 'darker'](0.7).toString(),\n    ),\n  );\n\n  const emptyColor = colorAsRgbaOr(\n    inputColors?.locationCircles?.empty,\n    darkMode ? '#000' : '#fff',\n  );\n  const innerColor = colorAsRgbaOr(\n    inputColors &&\n      inputColors.locationCircles &&\n      inputColors.locationCircles.inner,\n    maxFlowColorHcl.toString(),\n  );\n  return {\n    flows: {\n      scheme: flowColorScheme,\n      highlighted: flowColorHighlighted,\n    },\n    locationCircles: {\n      inner: innerColor,\n      outgoing: colorAsRgbaOr(\n        inputColors &&\n          inputColors.locationCircles &&\n          inputColors.locationCircles.outgoing,\n        darkMode ? '#000' : '#fff',\n      ),\n      incoming: colorAsRgbaOr(\n        inputColors &&\n          inputColors.locationCircles &&\n          inputColors.locationCircles.incoming,\n        maxFlowColorHcl[darkMode ? 'brighter' : 'darker'](1.25).toString(),\n      ),\n      highlighted: colorAsRgbaOr(\n        inputColors &&\n          inputColors.locationCircles &&\n          inputColors.locationCircles.highlighted,\n        flowColorHighlighted,\n      ),\n      empty: emptyColor,\n      outlineEmptyMix: inputColors?.locationCircles?.outlineEmptyMix ?? 0.4,\n    },\n  };\n}\n\nfunction getBaseColorsRGBA(\n  colors: Colors | DiffColors | undefined,\n): BaseColorsRGBA {\n  const darkMode = colors && colors.darkMode ? true : false;\n  return {\n    darkMode,\n    locationAreas: getLocationAreaColorsRGBA(\n      colors && colors.locationAreas,\n      darkMode,\n    ),\n    outlineColor: colorAsRgba(\n      (colors && colors.outlineColor) || DEFAULT_OUTLINE_COLOR,\n    ),\n    dimmedOpacity:\n      colors && colors.dimmedOpacity != null\n        ? colors.dimmedOpacity\n        : DEFAULT_DIMMED_OPACITY,\n  };\n}\n\nexport function getColorsRGBA(colors: Colors | undefined): ColorsRGBA {\n  const baseColorsRGBA = getBaseColorsRGBA(colors);\n  return {\n    ...baseColorsRGBA,\n    ...getFlowAndCircleColors(\n      colors,\n      DEFAULT_FLOW_COLOR_SCHEME,\n      baseColorsRGBA.darkMode,\n    ),\n  };\n}\n\nexport function getDiffColorsRGBA(\n  colors: DiffColors | undefined,\n): DiffColorsRGBA {\n  const baseColorsRGBA = getBaseColorsRGBA(colors);\n  return {\n    ...baseColorsRGBA,\n    positive: getFlowAndCircleColors(\n      colors && colors.positive,\n      DEFAULT_FLOW_COLOR_SCHEME_POSITIVE,\n      baseColorsRGBA.darkMode,\n    ),\n    negative: getFlowAndCircleColors(\n      colors && colors.negative,\n      DEFAULT_FLOW_COLOR_SCHEME_NEGATIVE,\n      baseColorsRGBA.darkMode,\n    ),\n  };\n}\n\nexport function rgbaAsString(color: RGBA): string {\n  return `rgba(${color.join(',')})`;\n}\n\nexport function midpoint(a: number, b: number, zeroToOne: number): number {\n  return a + (b - a) * zeroToOne;\n}\n\nexport function mixColorsRGBA(\n  color1: RGBA,\n  color2: RGBA,\n  zeroToOne: number,\n): RGBA {\n  return color1.map((v, i) => midpoint(v, color2[i], zeroToOne)) as RGBA;\n}\n\nexport default getColors;\n","import {\n  AggregateFlow,\n  ClusterNode,\n  FlowmapDataAccessors,\n  isAggregateFlow,\n  isCluster,\n  isLocationClusterNode,\n} from './types';\n\nexport default class FlowmapAggregateAccessors<L, F> {\n  private accessors: FlowmapDataAccessors<L, F>;\n  constructor(accessors: FlowmapDataAccessors<L, F>) {\n    this.accessors = accessors;\n  }\n\n  setAccessors(accessors: FlowmapDataAccessors<L, F>) {\n    this.accessors = accessors;\n  }\n\n  getFlowmapDataAccessors() {\n    return this.accessors;\n  }\n\n  getLocationId = (location: L | ClusterNode): string =>\n    isLocationClusterNode(location)\n      ? location.id\n      : this.accessors.getLocationId(location);\n\n  getLocationName = (location: L | ClusterNode): string =>\n    (isLocationClusterNode(location) && isCluster(location)\n      ? location.name\n      : undefined) ?? this.getLocationId(location);\n  // ? location.name // TODO getLocationName for locations and clusters\n  // : this.accessors.getLocationName\n  // ? this.accessors.getLocationName(location)\n  // : this.getLocationId(location);\n\n  getLocationCentroid = (location: L | ClusterNode): [number, number] =>\n    isLocationClusterNode(location)\n      ? location.centroid\n      : this.accessors.getLocationCentroid(location);\n\n  getFlowOriginId = (f: F | AggregateFlow) => {\n    return isAggregateFlow(f) ? f.origin : this.accessors.getFlowOriginId(f);\n  };\n\n  getFlowDestId = (f: F | AggregateFlow) => {\n    return isAggregateFlow(f) ? f.dest : this.accessors.getFlowDestId(f);\n  };\n\n  getFlowMagnitude = (f: F | AggregateFlow) => {\n    return isAggregateFlow(f) ? f.count : this.accessors.getFlowMagnitude(f);\n  };\n\n  // Note: Aggregate flows have no time\n  getFlowTime = (f: F) => {\n    const {getFlowTime} = this.accessors;\n    return getFlowTime ? getFlowTime(f) : undefined;\n  };\n}\n","import {timeFormat, timeParse} from 'd3-time-format';\nimport {\n  timeDay,\n  timeHour,\n  TimeInterval,\n  timeMinute,\n  timeMonth,\n  timeSecond,\n  timeWeek,\n  timeYear,\n} from 'd3-time';\n\nconst dateParsers = [\n  timeParse('%Y-%m-%d'),\n  timeParse('%Y-%m-%d %H:%M'),\n  timeParse('%Y-%m-%d %H:%M:%S'),\n  timeParse('%Y'),\n  timeParse('%Y-%m'),\n];\n\nexport function parseTime(input: string | Date | undefined): Date | undefined {\n  if (input != null) {\n    if (input instanceof Date) {\n      return input;\n    }\n    for (const parse of dateParsers) {\n      const date = parse(input);\n      if (date) {\n        return date;\n      }\n    }\n  }\n  return undefined;\n}\n\nexport enum TimeGranularityKey {\n  SECOND = 'SECOND',\n  MINUTE = 'MINUTE',\n  HOUR = 'HOUR',\n  DAY = 'DAY',\n  MONTH = 'MONTH',\n  YEAR = 'YEAR',\n}\n\nexport interface TimeGranularity {\n  key: TimeGranularityKey;\n  order: number;\n  interval: TimeInterval;\n  format: (date: Date) => string;\n  formatFull: (date: Date) => string;\n}\n\n// const preferredLocale = navigator.languages ? navigator.languages[0] : 'en';\n\nconst formatMillisecond = timeFormat('.%L'),\n  formatSecond = timeFormat(':%S'),\n  formatMinute = timeFormat('%I:%M'),\n  // formatHour = (d: Date) => d.toLocaleString(preferredLocale, { hour: 'numeric' }),\n  formatHour = timeFormat('%I %p'),\n  formatDay = timeFormat('%a %d'),\n  formatWeek = timeFormat('%b %d'),\n  formatMonth = timeFormat('%b'),\n  formatYear = timeFormat('%Y');\n\nexport function tickMultiFormat(date: Date) {\n  return (\n    timeSecond(date) < date\n      ? formatMillisecond\n      : timeMinute(date) < date\n      ? formatSecond\n      : timeHour(date) < date\n      ? formatMinute\n      : timeDay(date) < date\n      ? formatHour\n      : timeMonth(date) < date\n      ? timeWeek(date) < date\n        ? formatDay\n        : formatWeek\n      : timeYear(date) < date\n      ? formatMonth\n      : formatYear\n  )(date);\n}\n\nexport const TIME_GRANULARITIES: TimeGranularity[] = [\n  {\n    order: 0,\n    key: TimeGranularityKey.SECOND,\n    interval: timeSecond,\n    format: formatSecond,\n    formatFull: timeFormat('%Y-%m-%d %H:%M:%S'),\n  },\n  {\n    order: 1,\n    key: TimeGranularityKey.MINUTE,\n    interval: timeMinute,\n    format: formatMinute,\n    formatFull: timeFormat('%Y-%m-%d %H:%M'),\n  },\n  {\n    order: 2,\n    key: TimeGranularityKey.HOUR,\n    interval: timeHour,\n    // format: (d: Date) => d.toLocaleString(preferredLocale, { hour: 'numeric', minute: '2-digit' }),\n    format: formatHour,\n    formatFull: timeFormat('%a %d %b %Y, %I %p'),\n  },\n  {\n    order: 3,\n    key: TimeGranularityKey.DAY,\n    interval: timeDay,\n    format: formatDay,\n    formatFull: timeFormat('%a %d %b %Y'),\n  },\n  {\n    order: 4,\n    key: TimeGranularityKey.MONTH,\n    interval: timeMonth,\n    format: formatMonth,\n    formatFull: timeFormat('%b %Y'),\n  },\n  {\n    order: 5,\n    key: TimeGranularityKey.YEAR,\n    interval: timeYear,\n    format: formatYear,\n    formatFull: timeFormat('%Y'),\n  },\n];\n\nexport function getTimeGranularityByKey(key: TimeGranularityKey) {\n  return TIME_GRANULARITIES.find((s) => s.key === key);\n}\n\nexport function getTimeGranularityByOrder(order: number) {\n  return TIME_GRANULARITIES.find((s) => s.order === order);\n}\n\nexport function getTimeGranularityForDate(date: Date): TimeGranularity {\n  let prev = undefined;\n  for (const current of TIME_GRANULARITIES) {\n    const {interval} = current;\n    const floored = interval(date);\n    if (floored < date) {\n      if (!prev) return current;\n      return prev;\n    }\n    prev = current;\n  }\n  return TIME_GRANULARITIES[TIME_GRANULARITIES.length - 1];\n}\n\nexport function areRangesEqual(\n  a: [Date, Date] | undefined,\n  b: [Date, Date] | undefined,\n): boolean {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return a[0] === b[0] && a[1] === b[1];\n}\n","/*\n * Copyright 2022 FlowmapBlue\n * Copyright 2018-2020 Teralytics, modified by FlowmapBlue\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {WebMercatorViewport} from '@math.gl/web-mercator';\nimport {ascending, descending, extent, min} from 'd3-array';\nimport {nest} from 'd3-collection';\nimport {ScaleLinear, scaleLinear, scaleSqrt} from 'd3-scale';\nimport KDBush from 'kdbush';\nimport {\n  createSelector,\n  createSelectorCreator,\n  defaultMemoize,\n  ParametricSelector,\n} from 'reselect';\nimport {alea} from 'seedrandom';\nimport {clusterLocations} from './cluster/cluster';\nimport {\n  buildIndex,\n  ClusterIndex,\n  findAppropriateZoomLevel,\n  makeLocationWeightGetter,\n} from './cluster/ClusterIndex';\nimport getColors, {\n  ColorsRGBA,\n  DiffColorsRGBA,\n  getColorsRGBA,\n  getDiffColorsRGBA,\n  getFlowColorScale,\n  isDiffColors,\n  isDiffColorsRGBA,\n} from './colors';\nimport FlowmapAggregateAccessors from './FlowmapAggregateAccessors';\nimport {FlowmapState} from './FlowmapState';\nimport {\n  getTimeGranularityByKey,\n  getTimeGranularityByOrder,\n  getTimeGranularityForDate,\n  TimeGranularityKey,\n} from './time';\nimport {\n  AggregateFlow,\n  Cluster,\n  ClusterNode,\n  CountByTime,\n  FlowAccessors,\n  FlowCirclesLayerAttributes,\n  FlowLinesLayerAttributes,\n  FlowmapData,\n  FlowmapDataAccessors,\n  isCluster,\n  isLocationClusterNode,\n  LayersData,\n  LocationFilterMode,\n  LocationTotals,\n} from './types';\n\nconst MAX_CLUSTER_ZOOM_LEVEL = 20;\ntype KDBushTree = any;\n\nexport type Selector<L, F, T> = ParametricSelector<\n  FlowmapState,\n  FlowmapData<L, F>,\n  T\n>;\n\nexport default class FlowmapSelectors<L, F> {\n  accessors: FlowmapAggregateAccessors<L, F>;\n\n  constructor(accessors: FlowmapDataAccessors<L, F>) {\n    this.accessors = new FlowmapAggregateAccessors(accessors);\n    this.setAccessors(accessors);\n  }\n\n  setAccessors(accessors: FlowmapDataAccessors<L, F>) {\n    this.accessors = new FlowmapAggregateAccessors(accessors);\n  }\n\n  getFetchedFlows = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    props.flows;\n  getFetchedLocations = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    props.locations;\n  getMaxTopFlowsDisplayNum = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    state.settingsState.maxTopFlowsDisplayNum;\n  getSelectedLocations = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    state.filterState.selectedLocations;\n  getLocationFilterMode = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    state.filterState.locationFilterMode;\n  getClusteringEnabled = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    state.settingsState.clusteringEnabled;\n  getLocationTotalsEnabled = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    state.settingsState.locationTotalsEnabled;\n  getZoom = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    state.viewport.zoom;\n  getViewport = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    state.viewport;\n  getSelectedTimeRange = (state: FlowmapState, props: FlowmapData<L, F>) =>\n    state.filterState.selectedTimeRange;\n\n  getColorSchemeKey: Selector<L, F, string | undefined> = (\n    state: FlowmapState,\n    props: FlowmapData<L, F>,\n  ) => state.settingsState.colorScheme;\n\n  getDarkMode: Selector<L, F, boolean> = (\n    state: FlowmapState,\n    props: FlowmapData<L, F>,\n  ) => state.settingsState.darkMode;\n\n  getFadeEnabled: Selector<L, F, boolean> = (\n    state: FlowmapState,\n    props: FlowmapData<L, F>,\n  ) => state.settingsState.fadeEnabled;\n\n  getFadeOpacityEnabled: Selector<L, F, boolean> = (\n    state: FlowmapState,\n    props: FlowmapData<L, F>,\n  ) => state.settingsState.fadeOpacityEnabled;\n\n  getFadeAmount: Selector<L, F, number> = (\n    state: FlowmapState,\n    props: FlowmapData<L, F>,\n  ) => state.settingsState.fadeAmount;\n\n  getAnimate: Selector<L, F, boolean> = (\n    state: FlowmapState,\n    props: FlowmapData<L, F>,\n  ) => state.settingsState.animationEnabled;\n\n  getInvalidLocationIds: Selector<L, F, string[] | undefined> = createSelector(\n    this.getFetchedLocations,\n    (locations) => {\n      if (!locations) return undefined;\n      const invalid = [];\n      for (const location of locations) {\n        const id = this.accessors.getLocationId(location);\n        const [lon, lat] = this.accessors.getLocationCentroid(location) || [\n          NaN,\n          NaN,\n        ];\n        if (!(-90 <= lat && lat <= 90) || !(-180 <= lon && lon <= 180)) {\n          invalid.push(id);\n        }\n      }\n      return invalid.length > 0 ? invalid : undefined;\n    },\n  );\n\n  getLocations: Selector<L, F, L[] | undefined> = createSelector(\n    this.getFetchedLocations,\n    this.getInvalidLocationIds,\n    (locations, invalidIds) => {\n      if (!locations) return undefined;\n      if (!invalidIds || invalidIds.length === 0) return locations;\n      const invalid = new Set(invalidIds);\n      return locations.filter(\n        (location: L) => !invalid.has(this.accessors.getLocationId(location)),\n      );\n    },\n  );\n\n  getLocationIds: Selector<L, F, Set<string> | undefined> = createSelector(\n    this.getLocations,\n    (locations) =>\n      locations\n        ? new Set(locations.map(this.accessors.getLocationId))\n        : undefined,\n  );\n\n  getSelectedLocationsSet: Selector<L, F, Set<string> | undefined> =\n    createSelector(this.getSelectedLocations, (ids) =>\n      ids && ids.length > 0 ? new Set(ids) : undefined,\n    );\n\n  getSortedFlowsForKnownLocations: Selector<L, F, F[] | undefined> =\n    createSelector(this.getFetchedFlows, this.getLocationIds, (flows, ids) => {\n      if (!ids || !flows) return undefined;\n      return flows\n        .filter(\n          (flow: F) =>\n            ids.has(this.accessors.getFlowOriginId(flow)) &&\n            ids.has(this.accessors.getFlowDestId(flow)),\n        )\n        .sort((a: F, b: F) =>\n          descending(\n            Math.abs(this.accessors.getFlowMagnitude(a)),\n            Math.abs(this.accessors.getFlowMagnitude(b)),\n          ),\n        );\n    });\n\n  getActualTimeExtent: Selector<L, F, [Date, Date] | undefined> =\n    createSelector(this.getSortedFlowsForKnownLocations, (flows) => {\n      if (!flows) return undefined;\n      let start = null;\n      let end = null;\n      for (const flow of flows) {\n        const time = this.accessors.getFlowTime(flow);\n        if (time) {\n          if (start == null || start > time) start = time;\n          if (end == null || end < time) end = time;\n        }\n      }\n      if (!start || !end) return undefined;\n      return [start, end];\n    });\n\n  getTimeGranularityKey: Selector<L, F, TimeGranularityKey | undefined> =\n    createSelector(\n      this.getSortedFlowsForKnownLocations,\n      this.getActualTimeExtent,\n      (flows, timeExtent) => {\n        if (!flows || !timeExtent) return undefined;\n\n        const minOrder = min(flows, (d) => {\n          const t = this.accessors.getFlowTime(d);\n          return t ? getTimeGranularityForDate(t).order : null;\n        });\n        if (minOrder == null) return undefined;\n        const timeGranularity = getTimeGranularityByOrder(minOrder);\n        return timeGranularity ? timeGranularity.key : undefined;\n      },\n    );\n\n  getTimeExtent: Selector<L, F, [Date, Date] | undefined> = createSelector(\n    this.getActualTimeExtent,\n    this.getTimeGranularityKey,\n    (timeExtent, timeGranularityKey) => {\n      const timeGranularity = timeGranularityKey\n        ? getTimeGranularityByKey(timeGranularityKey)\n        : undefined;\n      if (!timeExtent || !timeGranularity?.interval) return undefined;\n      const {interval} = timeGranularity;\n      return [timeExtent[0], interval.offset(interval.floor(timeExtent[1]), 1)];\n    },\n  );\n\n  getSortedFlowsForKnownLocationsFilteredByTime: Selector<\n    L,\n    F,\n    F[] | undefined\n  > = createSelector(\n    this.getSortedFlowsForKnownLocations,\n    this.getTimeExtent,\n    this.getSelectedTimeRange,\n    (flows, timeExtent, timeRange) => {\n      if (!flows) return undefined;\n      if (\n        !timeExtent ||\n        !timeRange ||\n        (timeExtent[0] === timeRange[0] && timeExtent[1] === timeRange[1])\n      ) {\n        return flows;\n      }\n      return flows.filter((flow) => {\n        const time = this.accessors.getFlowTime(flow);\n        return time && timeRange[0] <= time && time < timeRange[1];\n      });\n    },\n  );\n\n  getLocationsHavingFlows: Selector<L, F, L[] | undefined> = createSelector(\n    this.getSortedFlowsForKnownLocations,\n    this.getLocations,\n    (flows, locations) => {\n      if (!locations || !flows) return locations;\n      const withFlows = new Set();\n      for (const flow of flows) {\n        withFlows.add(this.accessors.getFlowOriginId(flow));\n        withFlows.add(this.accessors.getFlowDestId(flow));\n      }\n      return locations.filter((location: L) =>\n        withFlows.has(this.accessors.getLocationId(location)),\n      );\n    },\n  );\n\n  getLocationsById: Selector<L, F, Map<string, L> | undefined> = createSelector(\n    this.getLocationsHavingFlows,\n    (locations) => {\n      if (!locations) return undefined;\n      return nest<L, L>()\n        .key((d: L) => this.accessors.getLocationId(d))\n        .rollup(([d]) => d)\n        .map(locations) as any as Map<string, L>;\n    },\n  );\n\n  getClusterIndex: Selector<L, F, ClusterIndex<F> | undefined> = createSelector(\n    this.getLocationsHavingFlows,\n    this.getLocationsById,\n    this.getSortedFlowsForKnownLocations,\n    (locations, locationsById, flows) => {\n      if (!locations || !locationsById || !flows) return undefined;\n\n      const getLocationWeight = makeLocationWeightGetter(\n        flows,\n        this.accessors.getFlowmapDataAccessors(),\n      );\n      const clusterLevels = clusterLocations(\n        locations,\n        this.accessors.getFlowmapDataAccessors(),\n        getLocationWeight,\n        {\n          maxZoom: MAX_CLUSTER_ZOOM_LEVEL,\n        },\n      );\n      const clusterIndex = buildIndex<F>(clusterLevels);\n      const {getLocationName, getLocationClusterName} =\n        this.accessors.getFlowmapDataAccessors();\n\n      // Adding meaningful names\n      const getName = (id: string) => {\n        const loc = locationsById.get(id);\n        if (loc) {\n          return getLocationName\n            ? getLocationName(loc)\n            : this.accessors.getLocationId(loc) || id;\n        }\n        return `\"${id}\"`;\n      };\n      for (const level of clusterLevels) {\n        for (const node of level.nodes) {\n          // Here mutating the nodes (adding names)\n          if (isCluster(node)) {\n            const leaves = clusterIndex.expandCluster(node);\n\n            leaves.sort((a, b) =>\n              descending(getLocationWeight(a), getLocationWeight(b)),\n            );\n\n            if (getLocationClusterName) {\n              node.name = getLocationClusterName(leaves);\n            } else {\n              const topId = leaves[0];\n              const otherId = leaves.length === 2 ? leaves[1] : undefined;\n              node.name = `\"${getName(topId)}\" and ${\n                otherId\n                  ? `\"${getName(otherId)}\"`\n                  : `${leaves.length - 1} others`\n              }`;\n            }\n          } else {\n            (node as any).name = getName(node.id);\n          }\n        }\n      }\n\n      return clusterIndex;\n    },\n  );\n\n  getAvailableClusterZoomLevels = createSelector(\n    this.getClusterIndex,\n    this.getSelectedLocations,\n    (clusterIndex, selectedLocations): number[] | undefined => {\n      if (!clusterIndex) {\n        return undefined;\n      }\n\n      let maxZoom = Number.POSITIVE_INFINITY;\n      let minZoom = Number.NEGATIVE_INFINITY;\n\n      const adjust = (zoneId: string) => {\n        const cluster = clusterIndex.getClusterById(zoneId);\n        if (cluster) {\n          minZoom = Math.max(minZoom, cluster.zoom);\n          maxZoom = Math.min(maxZoom, cluster.zoom);\n        } else {\n          const zoom = clusterIndex.getMinZoomForLocation(zoneId);\n          minZoom = Math.max(minZoom, zoom);\n        }\n      };\n\n      if (selectedLocations) {\n        for (const id of selectedLocations) {\n          adjust(id);\n        }\n      }\n\n      return clusterIndex.availableZoomLevels.filter(\n        (level) => minZoom <= level && level <= maxZoom,\n      );\n    },\n  );\n\n  _getClusterZoom: Selector<L, F, number | undefined> = createSelector(\n    this.getClusterIndex,\n    this.getZoom,\n    this.getAvailableClusterZoomLevels,\n    (clusterIndex, mapZoom, availableClusterZoomLevels) => {\n      if (!clusterIndex) return undefined;\n      if (!availableClusterZoomLevels) {\n        return undefined;\n      }\n\n      const clusterZoom = findAppropriateZoomLevel(\n        availableClusterZoomLevels,\n        mapZoom,\n      );\n      return clusterZoom;\n    },\n  );\n\n  getClusterZoom = (state: FlowmapState, props: FlowmapData<L, F>) => {\n    const {settingsState} = state;\n    if (!settingsState.clusteringEnabled) return undefined;\n    if (settingsState.clusteringAuto || settingsState.clusteringLevel == null) {\n      return this._getClusterZoom(state, props);\n    }\n    return settingsState.clusteringLevel;\n  };\n\n  getLocationsForSearchBox: Selector<L, F, (L | Cluster)[] | undefined> =\n    createSelector(\n      this.getClusteringEnabled,\n      this.getLocationsHavingFlows,\n      this.getSelectedLocations,\n      this.getClusterZoom,\n      this.getClusterIndex,\n      (\n        clusteringEnabled,\n        locations,\n        selectedLocations,\n        clusterZoom,\n        clusterIndex,\n      ) => {\n        if (!locations) return undefined;\n        let result: (L | Cluster)[] = locations;\n        // if (clusteringEnabled) {\n        //   if (clusterIndex) {\n        //     const zoomItems = clusterIndex.getClusterNodesFor(clusterZoom);\n        //     if (zoomItems) {\n        //       result = result.concat(zoomItems.filter(isCluster));\n        //     }\n        //   }\n        // }\n\n        if (result && clusterIndex && selectedLocations) {\n          const toAppend = [];\n          for (const id of selectedLocations) {\n            const cluster = clusterIndex.getClusterById(id);\n            if (\n              cluster &&\n              !result.find(\n                (d) =>\n                  (isLocationClusterNode(d)\n                    ? d.id\n                    : this.accessors.getLocationId(d)) === id,\n              )\n            ) {\n              toAppend.push(cluster);\n            }\n          }\n          if (toAppend.length > 0) {\n            result = result.concat(toAppend);\n          }\n        }\n        return result;\n      },\n    );\n\n  getDiffMode: Selector<L, F, boolean> = createSelector(\n    this.getFetchedFlows,\n    (flows) => {\n      if (\n        flows &&\n        flows.find((f: F) => this.accessors.getFlowMagnitude(f) < 0)\n      ) {\n        return true;\n      }\n      return false;\n    },\n  );\n\n  _getFlowmapColors = createSelector(\n    this.getDiffMode,\n    this.getColorSchemeKey,\n    this.getDarkMode,\n    this.getFadeEnabled,\n    this.getFadeOpacityEnabled,\n    this.getFadeAmount,\n    this.getAnimate,\n    getColors,\n  );\n\n  getFlowmapColorsRGBA = createSelector(\n    this._getFlowmapColors,\n    (flowmapColors) => {\n      return isDiffColors(flowmapColors)\n        ? getDiffColorsRGBA(flowmapColors)\n        : getColorsRGBA(flowmapColors);\n    },\n  );\n\n  getUnknownLocations: Selector<L, F, Set<string> | undefined> = createSelector(\n    this.getLocationIds,\n    this.getFetchedFlows,\n    this.getSortedFlowsForKnownLocations,\n    (ids, flows, flowsForKnownLocations) => {\n      if (!ids || !flows) return undefined;\n      if (\n        flowsForKnownLocations &&\n        flows.length === flowsForKnownLocations.length\n      )\n        return undefined;\n      const missing = new Set<string>();\n      for (const flow of flows) {\n        if (!ids.has(this.accessors.getFlowOriginId(flow)))\n          missing.add(this.accessors.getFlowOriginId(flow));\n        if (!ids.has(this.accessors.getFlowDestId(flow)))\n          missing.add(this.accessors.getFlowDestId(flow));\n      }\n      return missing;\n    },\n  );\n\n  getSortedAggregatedFilteredFlows: Selector<\n    L,\n    F,\n    (F | AggregateFlow)[] | undefined\n  > = createSelector(\n    this.getClusterIndex,\n    this.getClusteringEnabled,\n    this.getSortedFlowsForKnownLocationsFilteredByTime,\n    this.getClusterZoom,\n    this.getTimeExtent,\n    (clusterTree, isClusteringEnabled, flows, clusterZoom, timeExtent) => {\n      if (!flows) return undefined;\n      let aggregated: (F | AggregateFlow)[];\n      if (isClusteringEnabled && clusterTree && clusterZoom != null) {\n        aggregated = clusterTree.aggregateFlows(\n          // TODO: aggregate across time\n          // timeExtent != null\n          //   ? aggregateFlows(flows) // clusterTree.aggregateFlows won't aggregate unclustered across time\n          //   : flows,\n          flows,\n          clusterZoom,\n          this.accessors.getFlowmapDataAccessors(),\n        );\n      } else {\n        aggregated = aggregateFlows(\n          flows,\n          this.accessors.getFlowmapDataAccessors(),\n        );\n      }\n      aggregated.sort((a, b) =>\n        descending(\n          Math.abs(this.accessors.getFlowMagnitude(a)),\n          Math.abs(this.accessors.getFlowMagnitude(b)),\n        ),\n      );\n      return aggregated;\n    },\n  );\n\n  getFlowMagnitudeExtent: Selector<L, F, [number, number] | undefined> =\n    createSelector(\n      this.getSortedAggregatedFilteredFlows,\n      this.getSelectedLocationsSet,\n      this.getLocationFilterMode,\n      (flows, selectedLocationsSet, locationFilterMode) => {\n        if (!flows) return undefined;\n        let rv: [number, number] | undefined = undefined;\n        for (const f of flows) {\n          if (\n            this.accessors.getFlowOriginId(f) !==\n              this.accessors.getFlowDestId(f) &&\n            this.isFlowInSelection(f, selectedLocationsSet, locationFilterMode)\n          ) {\n            const count = this.accessors.getFlowMagnitude(f);\n            if (rv == null) {\n              rv = [count, count];\n            } else {\n              if (count < rv[0]) rv[0] = count;\n              if (count > rv[1]) rv[1] = count;\n            }\n          }\n        }\n        return rv;\n      },\n    );\n\n  getExpandedSelectedLocationsSet: Selector<L, F, Set<string> | undefined> =\n    createSelector(\n      this.getClusteringEnabled,\n      this.getSelectedLocationsSet,\n      this.getClusterIndex,\n      (clusteringEnabled, selectedLocations, clusterIndex) => {\n        if (!selectedLocations || !clusterIndex) {\n          return selectedLocations;\n        }\n\n        const result = new Set<string>();\n        for (const locationId of selectedLocations) {\n          const cluster = clusterIndex.getClusterById(locationId);\n          if (cluster) {\n            const expanded = clusterIndex.expandCluster(cluster);\n            for (const id of expanded) {\n              result.add(id);\n            }\n          } else {\n            result.add(locationId);\n          }\n        }\n        return result;\n      },\n    );\n\n  getTotalCountsByTime: Selector<L, F, CountByTime[] | undefined> =\n    createSelector(\n      this.getSortedFlowsForKnownLocations,\n      this.getTimeGranularityKey,\n      this.getTimeExtent,\n      this.getExpandedSelectedLocationsSet,\n      this.getLocationFilterMode,\n      (\n        flows,\n        timeGranularityKey,\n        timeExtent,\n        selectedLocationSet,\n        locationFilterMode,\n      ) => {\n        const timeGranularity = timeGranularityKey\n          ? getTimeGranularityByKey(timeGranularityKey)\n          : undefined;\n        if (!flows || !timeGranularity || !timeExtent) return undefined;\n        const byTime = flows.reduce((m, flow) => {\n          if (\n            this.isFlowInSelection(\n              flow,\n              selectedLocationSet,\n              locationFilterMode,\n            )\n          ) {\n            const key = timeGranularity\n              .interval(this.accessors.getFlowTime(flow))\n              .getTime();\n            m.set(\n              key,\n              (m.get(key) ?? 0) + this.accessors.getFlowMagnitude(flow),\n            );\n          }\n          return m;\n        }, new Map<number, number>());\n\n        return Array.from(byTime.entries()).map(([millis, count]) => ({\n          time: new Date(millis),\n          count,\n        }));\n      },\n    );\n\n  getMaxLocationCircleSize: Selector<L, F, number> = createSelector(\n    this.getLocationTotalsEnabled,\n    (locationTotalsEnabled) => (locationTotalsEnabled ? 17 : 1),\n  );\n\n  getViewportBoundingBox: Selector<L, F, [number, number, number, number]> =\n    createSelector(\n      this.getViewport,\n      this.getMaxLocationCircleSize,\n      (viewport, maxLocationCircleSize) => {\n        const pad = maxLocationCircleSize;\n        const bounds = new WebMercatorViewport({\n          ...viewport,\n          width: viewport.width + pad * 2,\n          height: viewport.height + pad * 2,\n        }).getBounds();\n        return [bounds[0][0], bounds[0][1], bounds[1][0], bounds[1][1]];\n      },\n    );\n\n  getLocationsForZoom: Selector<L, F, L[] | ClusterNode[] | undefined> =\n    createSelector(\n      this.getClusteringEnabled,\n      this.getLocationsHavingFlows,\n      this.getClusterIndex,\n      this.getClusterZoom,\n      (clusteringEnabled, locationsHavingFlows, clusterIndex, clusterZoom) => {\n        if (clusteringEnabled && clusterIndex) {\n          return clusterIndex.getClusterNodesFor(clusterZoom);\n        } else {\n          return locationsHavingFlows;\n        }\n      },\n    );\n\n  getLocationTotals: Selector<L, F, Map<string, LocationTotals> | undefined> =\n    createSelector(\n      this.getLocationsForZoom,\n      this.getSortedAggregatedFilteredFlows,\n      this.getSelectedLocationsSet,\n      this.getLocationFilterMode,\n      (locations, flows, selectedLocationsSet, locationFilterMode) => {\n        if (!flows) return undefined;\n        const totals = new Map<string, LocationTotals>();\n        const add = (\n          id: string,\n          d: Partial<LocationTotals>,\n        ): LocationTotals => {\n          const rv = totals.get(id) ?? {\n            incomingCount: 0,\n            outgoingCount: 0,\n            internalCount: 0,\n          };\n          if (d.incomingCount != null) rv.incomingCount += d.incomingCount;\n          if (d.outgoingCount != null) rv.outgoingCount += d.outgoingCount;\n          if (d.internalCount != null) rv.internalCount += d.internalCount;\n          return rv;\n        };\n        for (const f of flows) {\n          if (\n            this.isFlowInSelection(f, selectedLocationsSet, locationFilterMode)\n          ) {\n            const originId = this.accessors.getFlowOriginId(f);\n            const destId = this.accessors.getFlowDestId(f);\n            const count = this.accessors.getFlowMagnitude(f);\n            if (originId === destId) {\n              totals.set(originId, add(originId, {internalCount: count}));\n            } else {\n              totals.set(originId, add(originId, {outgoingCount: count}));\n              totals.set(destId, add(destId, {incomingCount: count}));\n            }\n          }\n        }\n        return totals;\n      },\n    );\n\n  getLocationsTree: Selector<L, F, KDBushTree> = createSelector(\n    this.getLocationsForZoom,\n    (locations) => {\n      if (!locations) {\n        return undefined;\n      }\n      return new KDBush(\n        // @ts-ignore\n        locations,\n        (location: L | ClusterNode) =>\n          lngX(\n            isLocationClusterNode(location)\n              ? location.centroid[0]\n              : this.accessors.getLocationCentroid(location)[0],\n          ),\n        (location: L | ClusterNode) =>\n          latY(\n            isLocationClusterNode(location)\n              ? location.centroid[1]\n              : this.accessors.getLocationCentroid(location)[1],\n          ),\n      );\n    },\n  );\n\n  _getLocationIdsInViewport: Selector<L, F, Set<string> | undefined> =\n    createSelector(\n      this.getLocationsTree,\n      this.getViewportBoundingBox,\n      (tree: KDBushTree, bbox: [number, number, number, number]) => {\n        const ids = this._getLocationsInBboxIndices(tree, bbox);\n        if (ids) {\n          return new Set(\n            ids.map((idx: number) => tree.points[idx].id) as Array<string>,\n          );\n        }\n        return undefined;\n      },\n    );\n\n  getLocationIdsInViewport: Selector<L, F, Set<string> | undefined> =\n    createSelectorCreator(\n      defaultMemoize,\n      // @ts-ignore\n      (\n        s1: Set<string> | undefined,\n        s2: Set<string> | undefined,\n        index: number,\n      ) => {\n        if (s1 === s2) return true;\n        if (s1 == null || s2 == null) return false;\n        if (s1.size !== s2.size) return false;\n        for (const item of s1) if (!s2.has(item)) return false;\n        return true;\n      },\n    )(\n      this._getLocationIdsInViewport,\n      (locationIds: Set<string> | undefined) => {\n        if (!locationIds) return undefined;\n        return locationIds;\n      },\n    );\n\n  getTotalUnfilteredCount: Selector<L, F, number | undefined> = createSelector(\n    this.getSortedFlowsForKnownLocations,\n    (flows) => {\n      if (!flows) return undefined;\n      return flows.reduce(\n        (m, flow) => m + this.accessors.getFlowMagnitude(flow),\n        0,\n      );\n    },\n  );\n\n  getTotalFilteredCount: Selector<L, F, number | undefined> = createSelector(\n    this.getSortedAggregatedFilteredFlows,\n    this.getSelectedLocationsSet,\n    this.getLocationFilterMode,\n    (flows, selectedLocationSet, locationFilterMode) => {\n      if (!flows) return undefined;\n      const count = flows.reduce((m, flow) => {\n        if (\n          this.isFlowInSelection(flow, selectedLocationSet, locationFilterMode)\n        ) {\n          return m + this.accessors.getFlowMagnitude(flow);\n        }\n        return m;\n      }, 0);\n      return count;\n    },\n  );\n\n  _getLocationTotalsExtent: Selector<L, F, [number, number] | undefined> =\n    createSelector(this.getLocationTotals, (locationTotals) =>\n      calcLocationTotalsExtent(locationTotals, undefined),\n    );\n\n  _getLocationTotalsForViewportExtent: Selector<\n    L,\n    F,\n    [number, number] | undefined\n  > = createSelector(\n    this.getLocationTotals,\n    this.getLocationIdsInViewport,\n    (locationTotals, locationsInViewport) =>\n      calcLocationTotalsExtent(locationTotals, locationsInViewport),\n  );\n\n  getLocationTotalsExtent = (\n    state: FlowmapState,\n    props: FlowmapData<L, F>,\n  ): [number, number] | undefined => {\n    if (state.settingsState.adaptiveScalesEnabled) {\n      return this._getLocationTotalsForViewportExtent(state, props);\n    } else {\n      return this._getLocationTotalsExtent(state, props);\n    }\n  };\n\n  getFlowsForFlowmapLayer: Selector<L, F, (F | AggregateFlow)[] | undefined> =\n    createSelector(\n      this.getSortedAggregatedFilteredFlows,\n      this.getLocationIdsInViewport,\n      this.getSelectedLocationsSet,\n      this.getLocationFilterMode,\n      this.getMaxTopFlowsDisplayNum,\n      (\n        flows,\n        locationIdsInViewport,\n        selectedLocationsSet,\n        locationFilterMode,\n        maxTopFlowsDisplayNum,\n      ) => {\n        if (!flows || !locationIdsInViewport) return undefined;\n        const picked: (F | AggregateFlow)[] = [];\n        let pickedCount = 0;\n        for (const flow of flows) {\n          const origin = this.accessors.getFlowOriginId(flow);\n          const dest = this.accessors.getFlowDestId(flow);\n          if (\n            locationIdsInViewport.has(origin) ||\n            locationIdsInViewport.has(dest)\n          ) {\n            if (\n              this.isFlowInSelection(\n                flow,\n                selectedLocationsSet,\n                locationFilterMode,\n              )\n            ) {\n              if (origin !== dest) {\n                // exclude self-loops\n                picked.push(flow);\n                pickedCount++;\n              }\n            }\n          }\n          // Only keep top\n          if (pickedCount > maxTopFlowsDisplayNum) break;\n        }\n        // assuming they are sorted in descending order,\n        // we need ascending for rendering\n        return picked.reverse();\n      },\n    );\n\n  _getFlowMagnitudeExtent = (\n    state: FlowmapState,\n    props: FlowmapData<L, F>,\n  ): [number, number] | undefined => {\n    if (state.settingsState.adaptiveScalesEnabled) {\n      const flows = this.getFlowsForFlowmapLayer(state, props);\n      if (flows) {\n        const rv = extent(flows, this.accessors.getFlowMagnitude);\n        return rv[0] !== undefined && rv[1] !== undefined ? rv : undefined;\n      } else {\n        return undefined;\n      }\n    } else {\n      return this.getFlowMagnitudeExtent(state, props);\n    }\n  };\n\n  getLocationMaxAbsTotalGetter = createSelector(\n    this.getLocationTotals,\n    (locationTotals) => {\n      return (locationId: string) => {\n        const total = locationTotals?.get(locationId);\n        if (!total) return undefined;\n        return Math.max(\n          Math.abs(total.incomingCount + total.internalCount),\n          Math.abs(total.outgoingCount + total.internalCount),\n        );\n      };\n    },\n  );\n\n  getFlowThicknessScale = createSelector(\n    this.getFlowMagnitudeExtent,\n    (magnitudeExtent) => {\n      if (!magnitudeExtent) return undefined;\n      return scaleLinear()\n        .range([0.025, 0.5])\n        .domain([\n          0,\n          // should support diff mode too\n          Math.max.apply(\n            null,\n            magnitudeExtent.map((x: number | undefined) => Math.abs(x || 0)),\n          ),\n        ]);\n    },\n  );\n\n  getCircleSizeScale = createSelector(\n    this.getMaxLocationCircleSize,\n    this.getLocationTotalsEnabled,\n    this.getLocationTotalsExtent,\n    (maxLocationCircleSize, locationTotalsEnabled, locationTotalsExtent) => {\n      if (!locationTotalsEnabled) {\n        return () => maxLocationCircleSize;\n      }\n      if (!locationTotalsExtent) return undefined;\n      return scaleSqrt()\n        .range([0, maxLocationCircleSize])\n        .domain([\n          0,\n          // should support diff mode too\n          Math.max.apply(\n            null,\n            locationTotalsExtent.map((x: number | undefined) =>\n              Math.abs(x || 0),\n            ),\n          ),\n        ]);\n    },\n  );\n\n  getInCircleSizeGetter = createSelector(\n    this.getCircleSizeScale,\n    this.getLocationTotals,\n    (circleSizeScale, locationTotals) => {\n      return (locationId: string) => {\n        const total = locationTotals?.get(locationId);\n        if (total && circleSizeScale) {\n          return (\n            circleSizeScale(\n              Math.abs(total.incomingCount + total.internalCount),\n            ) || 0\n          );\n        }\n        return 0;\n      };\n    },\n  );\n\n  getOutCircleSizeGetter = createSelector(\n    this.getCircleSizeScale,\n    this.getLocationTotals,\n    (circleSizeScale, locationTotals) => {\n      return (locationId: string) => {\n        const total = locationTotals?.get(locationId);\n        if (total && circleSizeScale) {\n          return (\n            circleSizeScale(\n              Math.abs(total.outgoingCount + total.internalCount),\n            ) || 0\n          );\n        }\n        return 0;\n      };\n    },\n  );\n\n  getSortedLocationsForZoom: Selector<L, F, L[] | ClusterNode[] | undefined> =\n    createSelector(\n      this.getLocationsForZoom,\n      this.getInCircleSizeGetter,\n      this.getOutCircleSizeGetter,\n      (locations, getInCircleSize, getOutCircleSize) => {\n        if (!locations) return undefined;\n        const nextLocations = [...locations] as L[] | ClusterNode[];\n        return nextLocations.sort((a, b) => {\n          const idA = this.accessors.getLocationId(a);\n          const idB = this.accessors.getLocationId(b);\n          return ascending(\n            Math.max(getInCircleSize(idA), getOutCircleSize(idA)),\n            Math.max(getInCircleSize(idB), getOutCircleSize(idB)),\n          );\n        });\n      },\n    );\n\n  getLocationsForFlowmapLayer: Selector<\n    L,\n    F,\n    Array<L | ClusterNode> | undefined\n  > = createSelector(\n    this.getSortedLocationsForZoom,\n    // this.getLocationIdsInViewport,\n    (\n      locations,\n      // locationIdsInViewport\n    ) => {\n      // if (!locations) return undefined;\n      // if (!locationIdsInViewport) return locations;\n      // if (locationIdsInViewport.size === locations.length) return locations;\n      // const filtered = [];\n      // for (const loc of locations) {\n      //   if (locationIdsInViewport.has(loc.id)) {\n      //     filtered.push(loc);\n      //   }\n      // }\n      // return filtered;\n      // @ts-ignore\n      // return locations.filter(\n      //   (loc: L | ClusterNode) => locationIdsInViewport!.has(loc.id)\n      // );\n      // TODO: return location in viewport + \"connected\" ones\n      return locations;\n    },\n  );\n\n  getLocationsForFlowmapLayerById: Selector<\n    L,\n    F,\n    Map<string, L | ClusterNode> | undefined\n  > = createSelector(this.getLocationsForFlowmapLayer, (locations) => {\n    if (!locations) return undefined;\n    return locations.reduce(\n      (m, d) => (m.set(this.accessors.getLocationId(d), d), m),\n      new Map(),\n    );\n  });\n\n  getLayersData: Selector<L, F, LayersData> = createSelector(\n    this.getLocationsForFlowmapLayer,\n    this.getFlowsForFlowmapLayer,\n    this.getFlowmapColorsRGBA,\n    this.getLocationsForFlowmapLayerById,\n    this.getLocationIdsInViewport,\n    this.getInCircleSizeGetter,\n    this.getOutCircleSizeGetter,\n    this.getFlowThicknessScale,\n    this.getAnimate,\n    (\n      locations,\n      flows,\n      flowmapColors,\n      locationsById,\n      locationIdsInViewport,\n      getInCircleSize,\n      getOutCircleSize,\n      flowThicknessScale,\n      animationEnabled,\n    ) => {\n      return this._prepareLayersData(\n        locations,\n        flows,\n        flowmapColors,\n        locationsById,\n        locationIdsInViewport,\n        getInCircleSize,\n        getOutCircleSize,\n        flowThicknessScale,\n        animationEnabled,\n      );\n    },\n  );\n\n  prepareLayersData(state: FlowmapState, props: FlowmapData<L, F>): LayersData {\n    const locations = this.getLocationsForFlowmapLayer(state, props) || [];\n    const flows = this.getFlowsForFlowmapLayer(state, props) || [];\n    const flowmapColors = this.getFlowmapColorsRGBA(state, props);\n    const locationsById = this.getLocationsForFlowmapLayerById(state, props);\n    const locationIdsInViewport = this.getLocationIdsInViewport(state, props);\n    const getInCircleSize = this.getInCircleSizeGetter(state, props);\n    const getOutCircleSize = this.getOutCircleSizeGetter(state, props);\n    const flowThicknessScale = this.getFlowThicknessScale(state, props);\n    return this._prepareLayersData(\n      locations,\n      flows,\n      flowmapColors,\n      locationsById,\n      locationIdsInViewport,\n      getInCircleSize,\n      getOutCircleSize,\n      flowThicknessScale,\n      state.settingsState.animationEnabled,\n    );\n  }\n\n  _prepareLayersData(\n    locations: (L | ClusterNode)[] | undefined,\n    flows: (F | AggregateFlow)[] | undefined,\n    flowmapColors: DiffColorsRGBA | ColorsRGBA,\n    locationsById: Map<string, L | ClusterNode> | undefined,\n    locationIdsInViewport: Set<string> | undefined,\n    getInCircleSize: (locationId: string) => number,\n    getOutCircleSize: (locationId: string) => number,\n    flowThicknessScale: ScaleLinear<number, number, never> | undefined,\n    animationEnabled: boolean,\n  ): LayersData {\n    if (!locations) locations = [];\n    if (!flows) flows = [];\n    const {\n      getFlowOriginId,\n      getFlowDestId,\n      getFlowMagnitude,\n      getLocationId,\n      getLocationCentroid,\n    } = this.accessors;\n\n    const getCentroid = (id: string) => {\n      const loc = locationsById?.get(id);\n      return loc ? getLocationCentroid(loc) : [0, 0];\n    };\n\n    const flowMagnitudeExtent = extent(flows, (f) => getFlowMagnitude(f)) as [\n      number,\n      number,\n    ];\n    const flowColorScale = getFlowColorScale(\n      flowmapColors,\n      flowMagnitudeExtent,\n      false,\n    );\n\n    // Using a generator here helps to avoid creating intermediary arrays\n    const circlePositions = Float32Array.from(\n      (function* () {\n        for (const location of locations) {\n          // yield* effectively works as flatMap here\n          yield* getLocationCentroid(location);\n        }\n      })(),\n    );\n\n    // TODO: diff mode\n    const circleColor = isDiffColorsRGBA(flowmapColors)\n      ? flowmapColors.positive.locationCircles.inner\n      : flowmapColors.locationCircles.inner;\n\n    const circleColors = Uint8Array.from(\n      (function* () {\n        for (const location of locations) {\n          yield* circleColor;\n        }\n      })(),\n    );\n\n    const inCircleRadii = Float32Array.from(\n      (function* () {\n        for (const location of locations) {\n          const id = getLocationId(location);\n          yield locationIdsInViewport?.has(id) ? getInCircleSize(id) : 1.0;\n        }\n      })(),\n    );\n    const outCircleRadii = Float32Array.from(\n      (function* () {\n        for (const location of locations) {\n          const id = getLocationId(location);\n          yield locationIdsInViewport?.has(id) ? getOutCircleSize(id) : 1.0;\n        }\n      })(),\n    );\n\n    const sourcePositions = Float32Array.from(\n      (function* () {\n        for (const flow of flows) {\n          yield* getCentroid(getFlowOriginId(flow));\n        }\n      })(),\n    );\n    const targetPositions = Float32Array.from(\n      (function* () {\n        for (const flow of flows) {\n          yield* getCentroid(getFlowDestId(flow));\n        }\n      })(),\n    );\n    const thicknesses = Float32Array.from(\n      (function* () {\n        for (const flow of flows) {\n          yield flowThicknessScale\n            ? flowThicknessScale(getFlowMagnitude(flow)) || 0\n            : 0;\n        }\n      })(),\n    );\n    const endpointOffsets = Float32Array.from(\n      (function* () {\n        for (const flow of flows) {\n          const originId = getFlowOriginId(flow);\n          const destId = getFlowDestId(flow);\n          yield Math.max(getInCircleSize(originId), getOutCircleSize(originId));\n          yield Math.max(getInCircleSize(destId), getOutCircleSize(destId));\n        }\n      })(),\n    );\n    const flowLineColors = Uint8Array.from(\n      (function* () {\n        for (const flow of flows) {\n          yield* flowColorScale(getFlowMagnitude(flow));\n        }\n      })(),\n    );\n\n    const staggeringValues = animationEnabled\n      ? Float32Array.from(\n          (function* () {\n            for (const f of flows) {\n              // @ts-ignore\n              yield new alea(`${getFlowOriginId(f)}-${getFlowDestId(f)}`)();\n            }\n          })(),\n        )\n      : undefined;\n\n    return {\n      circleAttributes: {\n        length: locations.length,\n        attributes: {\n          getPosition: {value: circlePositions, size: 2},\n          getColor: {value: circleColors, size: 4},\n          getInRadius: {value: inCircleRadii, size: 1},\n          getOutRadius: {value: outCircleRadii, size: 1},\n        },\n      },\n      lineAttributes: {\n        length: flows.length,\n        attributes: {\n          getSourcePosition: {value: sourcePositions, size: 2},\n          getTargetPosition: {value: targetPositions, size: 2},\n          getThickness: {value: thicknesses, size: 1},\n          getColor: {value: flowLineColors, size: 4},\n          getEndpointOffsets: {value: endpointOffsets, size: 2},\n          ...(staggeringValues\n            ? {getStaggering: {value: staggeringValues, size: 1}}\n            : {}),\n        },\n      },\n    };\n  }\n\n  getLocationsInBbox(\n    tree: KDBushTree,\n    bbox: [number, number, number, number],\n  ): Array<L> | undefined {\n    if (!tree) return undefined;\n    return this._getLocationsInBboxIndices(tree, bbox).map(\n      (idx: number) => tree.points[idx],\n    ) as Array<L>;\n  }\n\n  _getLocationsInBboxIndices(\n    tree: KDBushTree,\n    bbox: [number, number, number, number],\n  ) {\n    if (!tree) return undefined;\n    const [lon1, lat1, lon2, lat2] = bbox;\n    const [x1, y1, x2, y2] = [lngX(lon1), latY(lat1), lngX(lon2), latY(lat2)];\n    return tree.range(\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    );\n  }\n\n  isFlowInSelection(\n    flow: F | AggregateFlow,\n    selectedLocationsSet: Set<string> | undefined,\n    locationFilterMode: LocationFilterMode,\n  ) {\n    const origin = this.accessors.getFlowOriginId(flow);\n    const dest = this.accessors.getFlowDestId(flow);\n    if (selectedLocationsSet) {\n      switch (locationFilterMode) {\n        case LocationFilterMode.ALL:\n          return (\n            selectedLocationsSet.has(origin) || selectedLocationsSet.has(dest)\n          );\n        case LocationFilterMode.BETWEEN:\n          return (\n            selectedLocationsSet.has(origin) && selectedLocationsSet.has(dest)\n          );\n        case LocationFilterMode.INCOMING:\n          return selectedLocationsSet.has(dest);\n        case LocationFilterMode.OUTGOING:\n          return selectedLocationsSet.has(origin);\n      }\n    }\n    return true;\n  }\n\n  // calcLocationTotals(\n  //   locations: (L | ClusterNode)[],\n  //   flows: F[],\n  // ): LocationsTotals {\n  //   return flows.reduce(\n  //     (acc: LocationsTotals, curr) => {\n  //       const originId = this.accessors.getFlowOriginId(curr);\n  //       const destId = this.accessors.getFlowDestId(curr);\n  //       const magnitude = this.accessors.getFlowMagnitude(curr);\n  //       if (originId === destId) {\n  //         acc.internal[originId] = (acc.internal[originId] || 0) + magnitude;\n  //       } else {\n  //         acc.outgoing[originId] = (acc.outgoing[originId] || 0) + magnitude;\n  //         acc.incoming[destId] = (acc.incoming[destId] || 0) + magnitude;\n  //       }\n  //       return acc;\n  //     },\n  //     {incoming: {}, outgoing: {}, internal: {}},\n  //   );\n  // }\n}\n\nfunction calcLocationTotalsExtent(\n  locationTotals: Map<string, LocationTotals> | undefined,\n  locationIdsInViewport: Set<string> | undefined,\n) {\n  if (!locationTotals) return undefined;\n  let rv: [number, number] | undefined = undefined;\n  for (const [\n    id,\n    {incomingCount, outgoingCount, internalCount},\n  ] of locationTotals.entries()) {\n    if (locationIdsInViewport == null || locationIdsInViewport.has(id)) {\n      const lo = Math.min(\n        incomingCount + internalCount,\n        outgoingCount + internalCount,\n        internalCount,\n      );\n      const hi = Math.max(\n        incomingCount + internalCount,\n        outgoingCount + internalCount,\n        internalCount,\n      );\n      if (!rv) {\n        rv = [lo, hi];\n      } else {\n        if (lo < rv[0]) rv[0] = lo;\n        if (hi > rv[1]) rv[1] = hi;\n      }\n    }\n  }\n  return rv;\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng: number) {\n  return lng / 360 + 0.5;\n}\n\nfunction latY(lat: number) {\n  const sin = Math.sin((lat * Math.PI) / 180);\n  const y = 0.5 - (0.25 * Math.log((1 + sin) / (1 - sin))) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\nfunction aggregateFlows<F>(\n  flows: F[],\n  flowAccessors: FlowAccessors<F>,\n): AggregateFlow[] {\n  // Sum up flows with same origin, dest\n  const byOriginDest = nest<F, AggregateFlow>()\n    .key(flowAccessors.getFlowOriginId)\n    .key(flowAccessors.getFlowDestId)\n    .rollup((ff: F[]) => {\n      const origin = flowAccessors.getFlowOriginId(ff[0]);\n      const dest = flowAccessors.getFlowDestId(ff[0]);\n      // const color = ff[0].color;\n      const rv: AggregateFlow = {\n        aggregate: true,\n        origin,\n        dest,\n        count: ff.reduce((m, f) => {\n          const count = flowAccessors.getFlowMagnitude(f);\n          if (count) {\n            if (!isNaN(count) && isFinite(count)) return m + count;\n          }\n          return m;\n        }, 0),\n        // time: undefined,\n      };\n      // if (color) rv.color = color;\n      return rv;\n    })\n    .entries(flows);\n  const rv: AggregateFlow[] = [];\n  for (const {values} of byOriginDest) {\n    for (const {value} of values) {\n      rv.push(value);\n    }\n  }\n  return rv;\n}\n\n/**\n * This is used to augment hover picking info so that we can displace location tooltip\n * @param circleAttributes\n * @param index\n */\nexport function getOuterCircleRadiusByIndex(\n  circleAttributes: FlowCirclesLayerAttributes,\n  index: number,\n): number {\n  const {getInRadius, getOutRadius} = circleAttributes.attributes;\n  return Math.max(getInRadius.value[index], getOutRadius.value[index]);\n}\n\nexport function getLocationCentroidByIndex(\n  circleAttributes: FlowCirclesLayerAttributes,\n  index: number,\n): [number, number] {\n  const {getPosition} = circleAttributes.attributes;\n  return [getPosition.value[index * 2], getPosition.value[index * 2 + 1]];\n}\n\nexport function getFlowLineAttributesByIndex(\n  lineAttributes: FlowLinesLayerAttributes,\n  index: number,\n): FlowLinesLayerAttributes {\n  const {\n    getColor,\n    getEndpointOffsets,\n    getSourcePosition,\n    getTargetPosition,\n    getThickness,\n    getStaggering,\n  } = lineAttributes.attributes;\n  return {\n    length: 1,\n    attributes: {\n      getColor: {\n        value: getColor.value.subarray(index * 4, (index + 1) * 4),\n        size: 4,\n      },\n      getEndpointOffsets: {\n        value: getEndpointOffsets.value.subarray(index * 2, (index + 1) * 2),\n        size: 2,\n      },\n      getSourcePosition: {\n        value: getSourcePosition.value.subarray(index * 2, (index + 1) * 2),\n        size: 2,\n      },\n      getTargetPosition: {\n        value: getTargetPosition.value.subarray(index * 2, (index + 1) * 2),\n        size: 2,\n      },\n      getThickness: {\n        value: getThickness.value.subarray(index, index + 1),\n        size: 1,\n      },\n      ...(getStaggering\n        ? {\n            getStaggering: {\n              value: getStaggering.value.subarray(index, index + 1),\n              size: 1,\n            },\n          }\n        : undefined),\n    },\n  };\n}\n","/*\n * Copyright 2022 FlowmapBlue\n * Copyright 2018-2020 Teralytics, modified by FlowmapBlue\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  AggregateFlow,\n  Cluster,\n  ClusterLevels,\n  ClusterNode,\n  FlowAccessors,\n  FlowCountsMapReduce,\n  isCluster,\n} from './../types';\nimport {ascending, bisectLeft, extent} from 'd3-array';\n\nexport type LocationWeightGetter = (id: string) => number;\n\n/**\n * A data structure representing the cluster levels for efficient flow aggregation.\n */\nexport interface ClusterIndex<F> {\n  availableZoomLevels: number[];\n  getClusterById: (clusterId: string) => Cluster | undefined;\n  /**\n   * List the nodes on the given zoom level.\n   */\n  getClusterNodesFor: (zoom: number | undefined) => ClusterNode[] | undefined;\n  /**\n   * Get the min zoom level on which the location is not clustered.\n   */\n  getMinZoomForLocation: (locationId: string) => number;\n  /**\n   * List the IDs of all locations in the cluster (leaves of the subtree starting in the cluster).\n   */\n  expandCluster: (cluster: Cluster, targetZoom?: number) => string[];\n  /**\n   * Find the cluster the given location is residing in on the specified zoom level.\n   */\n  findClusterFor: (locationId: string, zoom: number) => string | undefined;\n  /**\n   * Aggregate flows for the specified zoom level.\n   */\n  aggregateFlows: (\n    flows: F[],\n    zoom: number,\n    {getFlowOriginId, getFlowDestId, getFlowMagnitude}: FlowAccessors<F>,\n    options?: {\n      flowCountsMapReduce?: FlowCountsMapReduce<F>;\n    },\n  ) => (F | AggregateFlow)[];\n}\n\n/**\n * Build ClusterIndex from the given cluster hierarchy\n */\nexport function buildIndex<F>(clusterLevels: ClusterLevels): ClusterIndex<F> {\n  const nodesByZoom = new Map<number, ClusterNode[]>();\n  const clustersById = new Map<string, Cluster>();\n  const minZoomByLocationId = new Map<string, number>();\n  for (const {zoom, nodes} of clusterLevels) {\n    nodesByZoom.set(zoom, nodes);\n    for (const node of nodes) {\n      if (isCluster(node)) {\n        clustersById.set(node.id, node);\n      } else {\n        const {id} = node;\n        const mz = minZoomByLocationId.get(id);\n        if (mz == null || mz > zoom) {\n          minZoomByLocationId.set(id, zoom);\n        }\n      }\n    }\n  }\n\n  const [minZoom, maxZoom] = extent(clusterLevels, (cl) => cl.zoom);\n  if (minZoom == null || maxZoom == null) {\n    throw new Error('Could not determine minZoom or maxZoom');\n  }\n\n  const leavesToClustersByZoom = new Map<number, Map<string, Cluster>>();\n\n  for (const cluster of clustersById.values()) {\n    const {zoom} = cluster;\n    let leavesToClusters = leavesToClustersByZoom.get(zoom);\n    if (!leavesToClusters) {\n      leavesToClusters = new Map<string, Cluster>();\n      leavesToClustersByZoom.set(zoom, leavesToClusters);\n    }\n    visitClusterLeaves(cluster, (leafId) => {\n      leavesToClusters?.set(leafId, cluster);\n    });\n  }\n\n  function visitClusterLeaves(cluster: Cluster, visit: (id: string) => void) {\n    for (const childId of cluster.children) {\n      const child = clustersById.get(childId);\n      if (child) {\n        visitClusterLeaves(child, visit);\n      } else {\n        visit(childId);\n      }\n    }\n  }\n\n  const expandCluster = (cluster: Cluster, targetZoom: number = maxZoom) => {\n    const ids: string[] = [];\n    const visit = (c: Cluster, expandedIds: string[]) => {\n      if (targetZoom > c.zoom) {\n        for (const childId of c.children) {\n          const child = clustersById.get(childId);\n          if (child) {\n            visit(child, expandedIds);\n          } else {\n            expandedIds.push(childId);\n          }\n        }\n      } else {\n        expandedIds.push(c.id);\n      }\n    };\n    visit(cluster, ids);\n    return ids;\n  };\n\n  function findClusterFor(locationId: string, zoom: number) {\n    const leavesToClusters = leavesToClustersByZoom.get(zoom);\n    if (!leavesToClusters) {\n      return undefined;\n    }\n    const cluster = leavesToClusters.get(locationId);\n    return cluster ? cluster.id : undefined;\n  }\n\n  const availableZoomLevels = clusterLevels\n    .map((cl) => +cl.zoom)\n    .sort((a, b) => ascending(a, b));\n\n  return {\n    availableZoomLevels,\n\n    getClusterNodesFor: (zoom) => {\n      if (zoom === undefined) {\n        return undefined;\n      }\n      return nodesByZoom.get(zoom);\n    },\n\n    getClusterById: (clusterId) => clustersById.get(clusterId),\n\n    getMinZoomForLocation: (locationId) =>\n      minZoomByLocationId.get(locationId) || minZoom,\n\n    expandCluster,\n\n    findClusterFor,\n\n    aggregateFlows: (\n      flows,\n      zoom,\n      {getFlowOriginId, getFlowDestId, getFlowMagnitude},\n      options = {},\n    ) => {\n      if (zoom > maxZoom) {\n        return flows;\n      }\n      const result: (F | AggregateFlow)[] = [];\n      const aggFlowsByKey = new Map<string, AggregateFlow>();\n      const makeKey = (origin: string, dest: string) => `${origin}:${dest}`;\n      const {\n        flowCountsMapReduce = {\n          map: getFlowMagnitude,\n          reduce: (acc: any, count: number) => (acc || 0) + count,\n        },\n      } = options;\n      for (const flow of flows) {\n        const origin = getFlowOriginId(flow);\n        const dest = getFlowDestId(flow);\n        const originCluster = findClusterFor(origin, zoom) || origin;\n        const destCluster = findClusterFor(dest, zoom) || dest;\n        const key = makeKey(originCluster, destCluster);\n        if (originCluster === origin && destCluster === dest) {\n          result.push(flow);\n        } else {\n          let aggregateFlow = aggFlowsByKey.get(key);\n          if (!aggregateFlow) {\n            aggregateFlow = {\n              origin: originCluster,\n              dest: destCluster,\n              count: flowCountsMapReduce.map(flow),\n              aggregate: true,\n            };\n            result.push(aggregateFlow);\n            aggFlowsByKey.set(key, aggregateFlow);\n          } else {\n            aggregateFlow.count = flowCountsMapReduce.reduce(\n              aggregateFlow.count,\n              flowCountsMapReduce.map(flow),\n            );\n          }\n        }\n      }\n      return result;\n    },\n  };\n}\n\nexport function makeLocationWeightGetter<F>(\n  flows: F[],\n  {getFlowOriginId, getFlowDestId, getFlowMagnitude}: FlowAccessors<F>,\n): LocationWeightGetter {\n  const locationTotals = {\n    incoming: new Map<string, number>(),\n    outgoing: new Map<string, number>(),\n  };\n  for (const flow of flows) {\n    const origin = getFlowOriginId(flow);\n    const dest = getFlowDestId(flow);\n    const count = getFlowMagnitude(flow);\n    locationTotals.incoming.set(\n      dest,\n      (locationTotals.incoming.get(dest) || 0) + count,\n    );\n    locationTotals.outgoing.set(\n      origin,\n      (locationTotals.outgoing.get(origin) || 0) + count,\n    );\n  }\n  return (id: string) =>\n    Math.max(\n      Math.abs(locationTotals.incoming.get(id) || 0),\n      Math.abs(locationTotals.outgoing.get(id) || 0),\n    );\n}\n\n/**\n * @param availableZoomLevels Must be sorted in ascending order\n * @param targetZoom\n */\nexport function findAppropriateZoomLevel(\n  availableZoomLevels: number[],\n  targetZoom: number,\n) {\n  if (!availableZoomLevels.length) {\n    throw new Error('No available zoom levels');\n  }\n  return availableZoomLevels[\n    Math.min(\n      bisectLeft(availableZoomLevels, Math.floor(targetZoom)),\n      availableZoomLevels.length - 1,\n    )\n  ];\n}\n","import {geoBounds} from 'd3-geo';\nimport {fitBounds} from '@math.gl/web-mercator';\nimport type {\n  FeatureCollection,\n  GeometryCollection,\n  GeometryObject,\n} from 'geojson';\nimport type {ViewState} from './types';\n\nexport type LocationProperties = any;\n\nexport type GetViewStateOptions = {\n  pad?: number; // size ratio\n  padding?: {top: number; bottom: number; left: number; right: number};\n  tileSize?: number;\n  // minZoom?: number;  // not supported by fitBounds\n  maxZoom?: number;\n};\n\nexport function getViewStateForFeatures(\n  featureCollection:\n    | FeatureCollection<GeometryObject, LocationProperties>\n    | GeometryCollection,\n  size: [number, number],\n  opts?: GetViewStateOptions,\n): ViewState & {width: number; height: number} {\n  const {pad = 0.05, maxZoom = 100} = opts || {};\n  const bounds = geoBounds(featureCollection as any);\n  const [[x1, y1], [x2, y2]] = bounds;\n  const paddedBounds: [[number, number], [number, number]] = pad\n    ? [\n        [x1 - pad * (x2 - x1), y1 - pad * (y2 - y1)],\n        [x2 + pad * (x2 - x1), y2 + pad * (y2 - y1)],\n      ]\n    : bounds;\n  const [width, height] = size;\n  return {\n    ...fitBounds({\n      width,\n      height,\n      bounds: paddedBounds,\n      padding: opts?.padding,\n      // minZoom,\n      maxZoom,\n    }),\n    width,\n    height,\n  };\n}\n\nexport function getViewStateForLocations(\n  locations: any[],\n  getLocationCentroid: (location: any) => [number, number],\n  size: [number, number],\n  opts?: GetViewStateOptions,\n): ViewState & {width: number; height: number} {\n  return getViewStateForFeatures(\n    {\n      type: 'GeometryCollection',\n      geometries: locations.map((location) => ({\n        type: 'Point',\n        coordinates: getLocationCentroid(location),\n      })),\n    } as any,\n    size,\n    opts,\n  );\n}\n","import type FlowmapDataProvider from './FlowmapDataProvider';\nimport type {\n  Cluster,\n  ClusterNode,\n  FlowmapData,\n  FlowmapDataAccessors,\n  LayersData,\n  LocationTotals,\n  ViewportProps,\n  AggregateFlow,\n} from '../types';\nimport {FlowmapState} from '../FlowmapState';\nimport FlowmapSelectors from '../FlowmapSelectors';\nimport {\n  GetViewStateOptions,\n  getViewStateForLocations,\n} from '../getViewStateForLocations';\n\nexport default class LocalFlowmapDataProvider<L, F>\n  implements FlowmapDataProvider<L, F>\n{\n  private selectors: FlowmapSelectors<L, F>;\n  private flowmapData: FlowmapData<L, F> | undefined;\n  private flowmapState: FlowmapState | undefined;\n\n  constructor(accessors: FlowmapDataAccessors<L, F>) {\n    // scope selectors to the concrete instance of FlowmapDataProvider\n    this.selectors = new FlowmapSelectors<L, F>(accessors);\n    this.flowmapData = undefined;\n    this.flowmapState = undefined;\n  }\n\n  setAccessors(accessors: FlowmapDataAccessors<L, F>) {\n    this.selectors.setAccessors(accessors);\n  }\n\n  async setFlowmapData(flowmapData: FlowmapData<L, F>): Promise<void> {\n    this.flowmapData = flowmapData;\n  }\n\n  async setFlowmapState(flowmapState: FlowmapState): Promise<void> {\n    this.flowmapState = flowmapState;\n  }\n\n  async getFlowByIndex(idx: number): Promise<F | AggregateFlow | undefined> {\n    if (!this.flowmapState || !this.flowmapData) {\n      return undefined;\n    }\n    const flows = this.selectors.getFlowsForFlowmapLayer(\n      this.flowmapState,\n      this.flowmapData,\n    );\n    return flows?.[idx];\n  }\n\n  async getLocationByIndex(idx: number): Promise<L | ClusterNode | undefined> {\n    if (!this.flowmapState || !this.flowmapData) {\n      return undefined;\n    }\n    const locations = this.selectors.getLocationsForFlowmapLayer(\n      this.flowmapState,\n      this.flowmapData,\n    );\n    return locations?.[idx];\n  }\n\n  async getLayersData(): Promise<LayersData | undefined> {\n    if (!this.flowmapState || !this.flowmapData) {\n      return undefined;\n    }\n    return this.selectors.getLayersData(this.flowmapState, this.flowmapData);\n  }\n\n  async getLocationById(id: string): Promise<L | Cluster | undefined> {\n    if (!this.flowmapState || !this.flowmapData) {\n      return undefined;\n    }\n    const clusterIndex = this.selectors.getClusterIndex(\n      this.flowmapState,\n      this.flowmapData,\n    );\n    if (clusterIndex) {\n      const cluster = clusterIndex.getClusterById(id);\n      if (cluster) {\n        return cluster;\n      }\n    }\n    const locationsById = this.selectors.getLocationsById(\n      this.flowmapState,\n      this.flowmapData,\n    );\n    return locationsById?.get(id);\n  }\n\n  async getTotalsForLocation(id: string): Promise<LocationTotals | undefined> {\n    if (!this.flowmapState || !this.flowmapData) {\n      return undefined;\n    }\n    return this.selectors\n      .getLocationTotals(this.flowmapState, this.flowmapData)\n      ?.get(id);\n  }\n\n  async getViewportForLocations(\n    dims: [number, number],\n    opts?: GetViewStateOptions,\n  ): Promise<ViewportProps | undefined> {\n    if (!this.flowmapData?.locations) {\n      return undefined;\n    }\n    // @ts-ignore\n    return getViewStateForLocations(\n      this.flowmapData.locations,\n      this.selectors.accessors.getLocationCentroid,\n      dims,\n      opts,\n    );\n  }\n}\n","import FlowmapDataProvider from './FlowmapDataProvider';\nimport {\n  Cluster,\n  ClusterNode,\n  FlowmapData,\n  FlowmapDataAccessors,\n  LayersData,\n  LocationTotals,\n  ViewportProps,\n} from '../types';\nimport {FlowmapState} from '../FlowmapState';\nimport {AggregateFlow} from '..';\nimport LocalFlowmapDataProvider from './LocalFlowmapDataProvider';\nimport {load} from '@loaders.gl/core';\nimport {CSVLoader} from '@loaders.gl/csv';\n\nconst LOADERS = [CSVLoader];\n\nexport type WorkerDataProviderProps = {\n  flows: {\n    url: string;\n    columns: {\n      originId: string;\n      destId: string;\n      count: string;\n    };\n  };\n  locations: {\n    url: string;\n    columns: {\n      id: string;\n      name: string;\n      lat: string;\n      lon: string;\n    };\n  };\n};\n\nexport type LocationDatum = Record<string, unknown>;\nexport type FlowDatum = Record<string, unknown>;\n\nexport default class WorkerFlowmapDataProvider\n  implements FlowmapDataProvider<LocationDatum, FlowDatum>\n{\n  private props: WorkerDataProviderProps;\n  private localProvider: LocalFlowmapDataProvider<LocationDatum, FlowDatum>;\n  private flowmapState: FlowmapState | undefined;\n\n  constructor(props: WorkerDataProviderProps) {\n    this.props = props;\n    this.localProvider = new LocalFlowmapDataProvider({\n      getFlowOriginId: (flow) => flow[props.flows.columns.originId] as string,\n      getFlowDestId: (flow) => flow[props.flows.columns.destId] as string,\n      getFlowMagnitude: (flow) => flow[props.flows.columns.count] as number,\n      // getFlowTime: (flow) => flow.time,\n      getLocationCentroid: (location) => [\n        location[props.locations.columns.lon] as number,\n        location[props.locations.columns.lat] as number,\n      ],\n      getLocationName: (location) =>\n        location[props.locations.columns.name] as string,\n      getLocationId: (location) =>\n        location[props.locations.columns.id] as string,\n    });\n    this.flowmapState = undefined;\n  }\n\n  async loadData() {\n    const [locations, flows] = await Promise.all([\n      load(this.props.locations.url, LOADERS),\n      load(this.props.flows.url, LOADERS),\n    ]);\n    await this.localProvider.setFlowmapData({locations, flows});\n  }\n\n  setAccessors(accessors: FlowmapDataAccessors<LocationDatum, FlowDatum>) {\n    throw new Error('Not supported');\n  }\n\n  async setFlowmapData(\n    flowmapData: FlowmapData<LocationDatum, FlowDatum>,\n  ): Promise<void> {\n    throw new Error('Not supported');\n  }\n\n  async setFlowmapState(flowmapState: FlowmapState): Promise<void> {\n    await this.localProvider.setFlowmapState(flowmapState);\n  }\n\n  async getFlowByIndex(\n    idx: number,\n  ): Promise<FlowDatum | AggregateFlow | undefined> {\n    return this.localProvider.getFlowByIndex(idx);\n  }\n\n  async getLocationByIndex(\n    idx: number,\n  ): Promise<LocationDatum | ClusterNode | undefined> {\n    return this.localProvider.getLocationByIndex(idx);\n  }\n\n  async getLayersData(): Promise<LayersData | undefined> {\n    return await this.localProvider.getLayersData();\n  }\n\n  async getLocationById(\n    id: string,\n  ): Promise<LocationDatum | Cluster | undefined> {\n    return this.localProvider.getLocationById(id);\n  }\n\n  async getTotalsForLocation(id: string): Promise<LocationTotals | undefined> {\n    return this.localProvider.getTotalsForLocation(id);\n  }\n\n  getViewportForLocations(\n    dims: [number, number],\n  ): Promise<ViewportProps | undefined> {\n    return this.localProvider.getViewportForLocations(dims);\n  }\n}\n","import {expose} from 'comlink';\nimport WorkerFlowmapDataProvider from './WorkerFlowmapDataProvider';\n\nexpose(WorkerFlowmapDataProvider);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [65], function() { return __webpack_require__(6445); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","__webpack_require__.amdO = {};","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"f71a9289\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/flowmap.gl/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t735: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunk_flowmap_gl_react_app\"] = self[\"webpackChunk_flowmap_gl_react_app\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(65).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["defaultOptions","minZoom","maxZoom","radius","extent","nodeSize","makeClusterName","id","numPoints","makeClusterId","isLeafPoint","p","index","isClusterPoint","createCluster","x","y","weight","zoom","Infinity","parentId","cluster","points","tree","options","clusters","r","Math","pow","i","length","neighborIds","within","wx","wy","neighborId","b","weight2","numPoints2","push","xLng","yLat","y2","PI","atan","exp","latY","lat","sin","log","getX","getY","isCluster","c","children","isLocationClusterNode","l","undefined","isAggregateFlow","flow","origin","dest","count","aggregate","LocationFilterMode","DEFAULT_FLOW_MIN_COLOR","DEFAULT_FLOW_COLOR_SCHEME","DEFAULT_FLOW_COLOR_SCHEME_POSITIVE","DEFAULT_FLOW_COLOR_SCHEME_NEGATIVE","FALLBACK_COLOR_RGBA","opacifyHex","hexCode","opacity","console","warn","col","rgb","g","colorAsRgba","color","rgbColor","floor","round","colorAsRgbaOr","defaultColor","asScheme","scheme","ColorScheme","getColorSteps","interpolate","range","SCALE_NUM_STEPS","map","reverse","FLOW_MIN_COLOR","GRAYISH","primary","schemeTeal","DEFAULT_COLOR_SCHEME","COLOR_SCHEMES","Blues","BluGrn","BluYl","BrwnYl","BuGn","BuPu","Burg","BurgYl","Cool","DarkMint","Emrld","GnBu","Grayish","Greens","Greys","Inferno","Magenta","Magma","Mint","Oranges","OrRd","OrYel","Peach","Plasma","PinkYl","PuBu","PuBuGn","PuRd","Purp","Purples","PurpOr","RdPu","RedOr","Reds","Sunset","SunsetDark","Teal","TealGrn","Viridis","Warm","YlGn","YlGnBu","YlOrBr","YlOrRd","diffColors","Object","keys","negative","flows","positive","locationAreas","outline","normal","outlineColor","getColors","diffMode","schemeKey","darkMode","fadeEnabled","fadeOpacityEnabled","fadeAmount","animate","slice","indices","max","N","colorScale","domain","amount","exponent","a","toString","locationCircles","outgoing","createFlowColorScale","scale","colors","spline","n","Array","t","interpolateRgbaBasis","value","isDiffColorsRGBA","getLocationAreaColorsRGBA","normalColor","normalColorHcl","locationAreasNormal","connected","highlighted","selected","getFlowAndCircleColors","inputColors","defaultFlowColorScheme","flowColorScheme","maxFlowColorHcl","flowColorHighlighted","emptyColor","empty","inner","incoming","outlineEmptyMix","getBaseColorsRGBA","dimmedOpacity","FlowmapAggregateAccessors","constructor","accessors","getLocationId","location","this","getLocationName","name","getLocationCentroid","centroid","getFlowOriginId","f","getFlowDestId","getFlowMagnitude","getFlowTime","setAccessors","getFlowmapDataAccessors","TimeGranularityKey","formatSecond","formatMinute","formatHour","formatDay","formatMonth","formatYear","TIME_GRANULARITIES","order","key","SECOND","interval","format","formatFull","MINUTE","HOUR","DAY","MONTH","YEAR","getTimeGranularityByKey","find","s","FlowmapSelectors","getFetchedFlows","state","props","getFetchedLocations","locations","getMaxTopFlowsDisplayNum","settingsState","maxTopFlowsDisplayNum","getSelectedLocations","filterState","selectedLocations","getLocationFilterMode","locationFilterMode","getClusteringEnabled","clusteringEnabled","getLocationTotalsEnabled","locationTotalsEnabled","getZoom","viewport","getViewport","getSelectedTimeRange","selectedTimeRange","getColorSchemeKey","colorScheme","getDarkMode","getFadeEnabled","getFadeOpacityEnabled","getFadeAmount","getAnimate","animationEnabled","getInvalidLocationIds","invalid","lon","NaN","getLocations","invalidIds","Set","filter","has","getLocationIds","getSelectedLocationsSet","ids","getSortedFlowsForKnownLocations","sort","descending","abs","getActualTimeExtent","start","end","time","getTimeGranularityKey","timeExtent","minOrder","min","d","date","prev","current","getTimeGranularityForDate","timeGranularity","getTimeExtent","timeGranularityKey","offset","getSortedFlowsForKnownLocationsFilteredByTime","timeRange","getLocationsHavingFlows","withFlows","add","getLocationsById","rollup","getClusterIndex","locationsById","getLocationWeight","locationTotals","Map","set","get","makeLocationWeightGetter","clusterLevels","locationAccessors","opts","trees","lng","Float32Array","z","numbersOfClusters","maxAvailZoom","indexOf","minAvailZoom","lastIndexOf","childrenByParent","point","nodes","Error","clusterLocations","clusterIndex","nodesByZoom","clustersById","minZoomByLocationId","node","mz","cl","leavesToClustersByZoom","values","leavesToClusters","visitClusterLeaves","leafId","visit","childId","child","findClusterFor","locationId","availableZoomLevels","ascending","getClusterNodesFor","getClusterById","clusterId","getMinZoomForLocation","expandCluster","targetZoom","expandedIds","aggregateFlows","result","aggFlowsByKey","makeKey","flowCountsMapReduce","reduce","acc","originCluster","destCluster","aggregateFlow","buildIndex","getLocationClusterName","getName","loc","level","leaves","topId","otherId","getAvailableClusterZoomLevels","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","adjust","zoneId","_getClusterZoom","mapZoom","availableClusterZoomLevels","bisect","findAppropriateZoomLevel","getClusterZoom","clusteringAuto","clusteringLevel","getLocationsForSearchBox","clusterZoom","toAppend","concat","getDiffMode","_getFlowmapColors","getFlowmapColorsRGBA","flowmapColors","isDiffColors","baseColorsRGBA","getDiffColorsRGBA","getColorsRGBA","getUnknownLocations","flowsForKnownLocations","missing","getSortedAggregatedFilteredFlows","clusterTree","isClusteringEnabled","aggregated","flowAccessors","byOriginDest","ff","m","isNaN","isFinite","entries","rv","getFlowMagnitudeExtent","selectedLocationsSet","isFlowInSelection","getExpandedSelectedLocationsSet","expanded","getTotalCountsByTime","selectedLocationSet","byTime","getTime","from","millis","Date","getMaxLocationCircleSize","getViewportBoundingBox","maxLocationCircleSize","pad","bounds","width","height","getBounds","getLocationsForZoom","locationsHavingFlows","getLocationTotals","totals","incomingCount","outgoingCount","internalCount","originId","destId","getLocationsTree","_getLocationIdsInViewport","bbox","_getLocationsInBboxIndices","idx","getLocationIdsInViewport","defaultMemoize","s1","s2","size","item","locationIds","getTotalUnfilteredCount","getTotalFilteredCount","_getLocationTotalsExtent","calcLocationTotalsExtent","_getLocationTotalsForViewportExtent","locationsInViewport","getLocationTotalsExtent","adaptiveScalesEnabled","getFlowsForFlowmapLayer","locationIdsInViewport","picked","pickedCount","_getFlowMagnitudeExtent","getLocationMaxAbsTotalGetter","total","getFlowThicknessScale","magnitudeExtent","apply","getCircleSizeScale","locationTotalsExtent","getInCircleSizeGetter","circleSizeScale","getOutCircleSizeGetter","getSortedLocationsForZoom","getInCircleSize","getOutCircleSize","idA","idB","getLocationsForFlowmapLayer","getLocationsForFlowmapLayerById","getLayersData","flowThicknessScale","_prepareLayersData","prepareLayersData","getCentroid","flowColorScale","minMagnitude","maxMagnitude","posScale","negScale","magnitude","getFlowColorScale","circlePositions","circleColor","circleColors","Uint8Array","inCircleRadii","outCircleRadii","sourcePositions","targetPositions","thicknesses","endpointOffsets","flowLineColors","staggeringValues","alea","circleAttributes","attributes","getPosition","getColor","getInRadius","getOutRadius","lineAttributes","getSourcePosition","getTargetPosition","getThickness","getEndpointOffsets","getStaggering","getLocationsInBbox","lon1","lat1","lon2","lat2","x1","y1","x2","ALL","BETWEEN","INCOMING","OUTGOING","lo","hi","getViewStateForLocations","featureCollection","paddedBounds","padding","getViewStateForFeatures","type","geometries","coordinates","LocalFlowmapDataProvider","selectors","flowmapData","flowmapState","setFlowmapData","setFlowmapState","getFlowByIndex","getLocationByIndex","getLocationById","getTotalsForLocation","getViewportForLocations","dims","LOADERS","localProvider","columns","loadData","Promise","all","load","url","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","loaded","__webpack_modules__","call","__webpack_exports__","O","amdD","amdO","deferred","chunkIds","fn","priority","notFulfilled","fulfilled","j","every","splice","definition","o","defineProperty","enumerable","e","chunkId","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","data","moreModules","runtime","pop","next","then"],"sourceRoot":""}